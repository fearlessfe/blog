{"categories":[],"posts":[{"content":"æœ€è¿‘é¢è¯• golang è¢«é—®åˆ°ï¼Œgolang é‡Œé¢çš„ mutex æ˜¯ä»€ä¹ˆç±»å‹çš„é”ã€‚å¾ˆæ— å¥ˆï¼Œæ²¡äº†è§£è¿‡ç›¸å…³çŸ¥è¯†ï¼Œæ²¡æœ‰ç­”å‡ºæ¥ã€‚\nåœ¨ google ä¸Šä¸€æœï¼Œå¯¹ Java ä¸­é”ä»‹ç»çš„èµ„æ–™æœ€å¤šï¼Œä»ä¸åŒçš„è§’åº¦å‡ºå‘ï¼Œé”çš„åˆ†ç±»ä¹Ÿä¸åŒã€‚ä¸‹å›¾å¼•ç”¨äº†ç¾å›¾æŠ€æœ¯åšå®¢çš„åˆ†ç±»\nä¸‹é¢å¯¹å…¶ä¸­çš„å‡ ç±»é”åšä¸€ä¸‹ç®€å•çš„ä»‹ç»ï¼Œç„¶åçœ‹çœ‹ mutex æ˜¯ä»€ä¹ˆç±»å‹çš„é”ã€‚\nä¹è§‚é”ï¼Œæ‚²è§‚é” ä¹è§‚é”å’Œæ‚²è§‚é”æ˜¯ä»¥æ˜¯å¦é”ä½åŒæ­¥èµ„æºæ¥åŒºåˆ†çš„ã€‚\nå¾ˆæ˜¾ç„¶ï¼Œmutex æ˜¯æ‚²è§‚é”ï¼Œgoroutine è·å–é”åï¼Œç›¸å…³çš„èµ„æºä¹Ÿä¼šé”ä½ï¼Œä¸è®©å…¶ä½™ goroutine æ“ä½œã€‚\né‚£ä¹ˆä¹è§‚é”æ˜¯æ€ä¹ˆå¤„ç†å¤šä¸ª goroutine çš„ç«äº‰å…³ç³»å‘¢ï¼Ÿç­”æ¡ˆå°±æ˜¯ CASï¼ˆCampare And Swapï¼‰ï¼Œå…ˆæ¯”è¾ƒï¼Œå†äº¤æ¢ã€‚ goé‡Œé¢çš„ atomic åŒ…æä¾›äº†ç›¸å…³æ–¹æ³•,ä»¥ CompareAndSwapInt32 ä¸ºä¾‹ï¼Œè¯¥æ–¹æ³•æ¥å—3ä¸ªå‚æ•°ï¼š\n å†…å­˜åœ°å€,addr éœ€è¦æ¯”è¾ƒçš„å€¼,old æ–°çš„å€¼,new  å°† addr å¤„çš„å€¼äº old æ¯”è¾ƒï¼Œå¦‚æœç›¸åŒï¼Œåˆ™å°† addr çš„å€¼è®¾ç½®ä¸º newï¼Œå¦åˆ™å°±è¿”å› falseã€‚\natomic.CompareAndSwapInt32(\u0026amp;addr, old, new)  CAS çš„æ€§èƒ½ä¼šè¿œé«˜äºé”ï¼Œä½†æ˜¯ CAS ä¹Ÿä¼šæœ‰ä¸€äº›ä¸é€‚ç”¨çš„æƒ…å†µã€‚\n ABA é—®é¢˜ï¼šCAS åªæ˜¯æ¯”è¾ƒå€¼æ˜¯å¦æ”¹å˜ï¼Œå¦‚æœè¯¥åœ°å€åˆå§‹å€¼ä¸º Aï¼Œåˆ«çš„ goroutine å°†å€¼æ”¹ä¸º Bï¼Œåæ¥ğŸˆ¶ï¸æœ‰ goroutine å°†å€¼æ”¹ä¸º Aã€‚CAS æ˜¯ä¸èƒ½åˆ¤æ–­è¿™ç§å˜åŒ–çš„ï¼Œå¯èƒ½ä¼šäº§ç”Ÿä¸€äº›é—®é¢˜ã€‚ åªèƒ½å¯¹ä¸€ä¸ªå˜é‡è¿›è¡Œæ“ä½œï¼Œæ— æ³•ä¿è¯å¤šä¸ªå˜é‡çš„åŸå­æ€§ã€‚  é™¤äº† CASï¼Œä½¿ç”¨ç‰ˆæœ¬å·ä¹Ÿå¯ä»¥å®ç°ä¹è§‚é”ã€‚\nç‰ˆæœ¬å·çš„åŸç†æ˜¯åœ¨æ•°æ®ä¸­åŠ ä¸€ä¸ª version å­—æ®µï¼Œæ¯æ¬¡å­—æ®µæ”¹å˜åï¼Œ version åŠ  1ã€‚æ¯æ¬¡æ›´æ–°æ—¶ï¼Œå…ˆæ¯”è¾ƒå½“å‰ç‰ˆæœ¬äºæ•°æ®ç›®å‰çš„ç‰ˆæœ¬æ˜¯å¦ä¸€è‡´ï¼Œå¦åˆ™å°±ä¸èƒ½æ›´æ–°æ•°æ®ã€‚\nå…¬å¹³é”ï¼Œéå…¬å¹³é” æŒ‰ç…§å¤šä¸ª goroutine ç«äº‰é”çš„æ—¶å€™ï¼Œæ˜¯å¦æŒ‰ç…§ FIFO çš„é¡ºåºæ¥è·å¾—é”ï¼Œå¯ä»¥åˆ†ä¸ºå…¬å¹³é”å’Œéå…¬å¹³é”ã€‚\nmutex çš„å®ç°ç»å†äº†å¤šä¸ªç‰ˆæœ¬ï¼Œæ—©æœŸç‰ˆæœ¬æ—¶æŒ‰ç…§ FIFO çš„æ–¹å¼æ¥å®ç°çš„ï¼Œæ˜¯å…¬å¹³é”ã€‚ä½†åæ¥çš„ç‰ˆæœ¬ä¸ºäº†æ€§èƒ½ï¼Œè¯¥ä¸ºäº†éå…¬å¹³é”ã€‚è¯¦ç»†èµ„æ–™å¯å‚è€ƒç›¸å…³æ–‡ç« ã€‚\nç›®å‰ mutex çš„å®ç°æ˜¯æ–°çš„ goroutine è¿›æ¥ä¼šå…ˆæ’é˜Ÿï¼Œæ’é˜Ÿå¤±è´¥åä¼šæ’é˜Ÿã€‚æ‰€ä»¥ mutex æ˜¯éå…¬å¹³é”ã€‚\nå…¶ä½™ç±»å‹ mutex æ˜¯äº’æ–¥é”ï¼Œåªèƒ½ç”±å•ä¸ª gouroutine è·å–ï¼Œè€Œä¸”ä¸èƒ½é‡å¤çš„å»è·å–åŒä¸€æŠŠé”ã€‚æ‰€ä»¥ mutex æ˜¯ä¸å¯é‡å…¥é”ï¼Œæ’å®ƒé”ã€‚\næ€»ç»“ mutex å¯ä»¥æ˜¯ æ‚²è§‚é”ï¼Œéå…¬å¹³é”ï¼Œä¸å¯é‡å…¥é”å’Œæ’å®ƒé”ã€‚\nå‚è€ƒèµ„æ–™ ã€BATé¢è¯•é¢˜ç³»åˆ—ã€‘é¢è¯•å®˜ï¼šä½ äº†è§£ä¹è§‚é”å’Œæ‚²è§‚é”å—ï¼Ÿ\nä¸å¯ä¸è¯´çš„Javaâ€œé”â€äº‹\n","id":0,"section":"posts","summary":"æœ€è¿‘é¢è¯• golang è¢«é—®åˆ°ï¼Œgolang é‡Œé¢çš„ mutex æ˜¯ä»€ä¹ˆç±»å‹çš„é”ã€‚å¾ˆæ— å¥ˆï¼Œæ²¡äº†è§£è¿‡ç›¸å…³çŸ¥è¯†ï¼Œæ²¡æœ‰ç­”å‡ºæ¥ã€‚ åœ¨ google ä¸Šä¸€æœï¼Œå¯¹ Java ä¸­é”ä»‹ç»çš„èµ„æ–™æœ€å¤šï¼Œä»ä¸åŒçš„è§’åº¦","tags":null,"title":"golang é‡Œé¢çš„ mutex æ˜¯ä»€ä¹ˆç±»å‹çš„é”ï¼Ÿ","uri":"https://fearlessfe.github.io/blog/2022/02/%E6%82%B2%E8%A7%82%E9%94%81%E4%B9%90%E8%A7%82%E9%94%81/","year":"2022"},{"content":"ä¸ºä»€ä¹ˆè¦å†™è¿™ç¯‡æ–‡ç«  æœ‰ä¸€æ®µæ—¶é—´ nodejs å·¥ä½œç»å†ï¼Œé¢è¯•æ€»æ˜¯è¢«é—®åˆ° Event Loop,è™½ç„¶çœ‹è¿‡å®˜ç½‘ä¸Šçš„æ–‡ç« ï¼Œå¥ˆä½•æ€»æ˜¯è®°ä¸ä½ï¼Œé¢è¯•ä¹Ÿç­”ä¸ä¸Šæ¥ã€‚å› æ­¤ï¼Œå†™è¿™ç¯‡æ–‡ç« æ¥åŠ æ·±å°è±¡ã€‚åŸæ–‡è¯·ğŸ‘‡è¿™é‡Œ\nä»€ä¹ˆæ˜¯ Event Loop è™½ç„¶ Javascript æ˜¯å•çº¿ç¨‹çš„ï¼Œä½†æ˜¯ Event Loop è®© Nodejs èƒ½å¤Ÿæ‰§è¡Œéé˜»å¡çš„ I/Oã€‚\nç°ä»£å†…æ ¸éƒ½æ˜¯å¤šçº¿ç¨‹çš„ï¼Œå®ƒä»¬å¯åœ¨åå°æ‰§è¡Œå¤šä¸ªæ“ä½œã€‚ä½†å…¶ä¸­ä¸€ä¸ªæ“ä½œå®Œæˆåï¼Œå†…æ ¸é€šçŸ¥ Nodejs ä»¥ä¾¿å°†ç›¸åº”çš„å›è°ƒæ·»åŠ åˆ°è½®è¯¢é˜Ÿåˆ—ï¼Œæœ€åå›è°ƒä¼šè¢«æ‰§è¡Œã€‚\nEvent Loopç®€ä»‹ å½“ Nodejs è¿è¡Œæ—¶ï¼Œå®ƒä¼šåˆå§‹åŒ–äº‹ä»¶å¾ªç¯ï¼Œæ‰§è¡Œè¾“å…¥çš„è„šæœ¬ï¼Œè„šæœ¬ä¸­å¯èƒ½ä¼šè°ƒç”¨å¼‚æ­¥çš„ APIï¼Œtimer å‡½æ•°æˆ– process.nextTick(),ç„¶åå¼€å§‹äº‹ä»¶å¾ªç¯ã€‚\nä¸‹å›¾ï¼ˆæ¥æºäºåŸæ–‡ï¼‰ç®€å•çš„æè¿°äº†äº‹ä»¶å¾ªç¯æ“ä½œé¡ºåºã€‚\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€\u0026gt;â”‚ timers â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ pending callbacks â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ idle, prepare â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ incoming: â”‚ â”‚ â”‚ poll â”‚\u0026lt;â”€â”€â”€â”€â”€â”¤ connections, â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ data, etc. â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ check â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â””â”€â”€â”¤ close callbacks â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n å›¾ä¸­æ¯ä¸ªç›’å­ä»£è¡¨äº‹ä»¶å¾ªç¯ä¸­ä¸€ä¸ªé˜¶æ®µ\n æ¯ä¸ªé˜¶æ®µéƒ½æ˜¯ä¸€ä¸ªé˜Ÿåˆ—ï¼ŒæŒ‰ç…§ FIFO çš„æ–¹å¼æ‰§è¡Œå›è°ƒå‡½æ•°ã€‚äº‹ä»¶å¾ªç¯è¿›å…¥å…¶ä¸­ä¸€ä¸ªé˜¶æ®µåï¼Œé¦–å…ˆä¼šæ‰§è¡Œè¯¥é˜¶æ®µç‰¹å®šçš„æ“ä½œã€‚ç„¶åæ‰§è¡Œè¯¥é˜¶æ®µé˜Ÿåˆ—ä¸­çš„å›è°ƒï¼ŒçŸ¥é“é˜Ÿåˆ—ä¸­å›è°ƒå…¨éƒ¨æ‰§è¡Œå®Œæˆ–è€…è¾¾åˆ°æœ€å¤§çš„å›è°ƒé™åˆ¶ï¼Œç„¶åäº‹ä»¶å¾ªç¯è¿›å…¥ä¸‹ä¸€ä¸ªé˜¶æ®µã€‚\nç”±äºè¿™äº›æ“ä½œå¯èƒ½ä¼šäº§ç”Ÿæ–°çš„äº‹ä»¶ï¼Œè€Œè½®è¯¢é˜¶æ®µï¼ˆpoll phaseï¼‰æ–°çš„äº‹ä»¶ç”±å†…æ ¸åŠ å…¥åˆ°é˜Ÿåˆ—ï¼Œå› æ­¤å¤„ç†è½®è¯¢äº‹ä»¶æ—¶ä¹Ÿä¼šæœ‰æ–°çš„äº‹ä»¶åŠ å…¥åˆ°é˜Ÿåˆ—ä¸­ã€‚å› æ­¤ï¼Œé•¿æ—¶é—´è¿è¡Œçš„å›è°ƒä¼šè®©è½®è¯¢é˜¶æ®µçš„æ—¶é—´è¿œè¶…è¿‡è®¡æ—¶å™¨çš„é˜ˆå€¼ã€‚\né˜¶æ®µæ¦‚è§ˆ  timers: è¿™ä¸ªé˜¶æ®µæ‰§è¡Œ setTimeout() å’Œ setInterval() çš„å›è°ƒ pending callbacksï¼šæ‰§è¡Œæ¨è¿Ÿåˆ°ä¸‹ä¸€ä¸ªå¾ªç¯çš„ I/O å›è°ƒ idle,prepare: ä»…ä¾›å†…éƒ¨ä½¿ç”¨ pollï¼ˆè½®è¯¢ï¼‰: æ£€ç´¢æ–°çš„ I/O äº‹ä»¶ï¼›æ‰§è¡Œ I/O ç›¸å…³çš„å›è°ƒï¼ˆå‡ ä¹æ‰€æœ‰çš„å›è°ƒï¼Œé™¤äº†å…³é—­å›è°ƒï¼Œå®šæ—¶å™¨è°ƒåº¦çš„å›è°ƒå’ŒsetImmediate()ï¼‰,èŠ‚ç‚¹ä¼šåœ¨é€‚å½“çš„æ—¶å€™é˜»å¡ã€‚ checkï¼šsetImmediate()çš„å›è°ƒåœ¨è¿™é‡Œæ‰§è¡Œã€‚ close callbacks: å…³é—­çš„å›è°ƒï¼Œæ¯”å¦‚socket.on('close',...)  åœ¨äº‹ä»¶å¾ªç¯ä¹‹é—´ï¼ŒNodejs ä¼šæ£€æŸ¥å®ƒæ˜¯å¦æ­£åœ¨ç­‰å¾…å¼‚æ­¥ I/O æˆ–è®¡æ—¶å™¨ã€‚å¦‚æœæ²¡æœ‰ï¼Œåˆ™é€€å‡ºã€‚ï¼ˆè¿™é‡Œé€€å‡ºåº”è¯¥æ˜¯æŒ‡é€€å‡º nodejs ç¨‹åºï¼‰ã€‚\né˜¶æ®µè¯¦æƒ… timers è®¡æ—¶å™¨å¯ä»¥æŒ‡å®šä¸€ä¸ªé˜ˆå€¼ï¼Œåˆ°è¾¾é˜ˆå€¼åæ‰§è¡Œå›è°ƒï¼Œè€Œä¸æ˜¯å†³å®šå›è°ƒæ‰§è¡Œçš„ç¡®åˆ‡æ—¶é—´ã€‚è®¡æ—¶å™¨çš„å›è°ƒä¼šåœ¨æŒ‡å®šçš„æ—¶é—´è¿‡åå°½å¯èƒ½æ—©çš„æ‰§è¡Œï¼Œä½†æ˜¯å›è°ƒçš„æ‰§è¡Œå¯èƒ½ä¼šå»¶è¿Ÿã€‚\n è½®è¯¢é˜¶æ®µæ§åˆ¶è®¡æ—¶å™¨å›è°ƒçš„æ‰§è¡Œ\n ä¸¾ä¸ªä¾‹å­ï¼Œå®šæ—¶å™¨åœ¨100msåæ‰§è¡Œå›è°ƒï¼Œç„¶åä¸€ä¸ªå¼‚æ­¥è¯»å–æ–‡ä»¶ä¼šèŠ± 95ms\nconst fs = require('fs'); function someAsyncOperation(callback) { fs.readFile('/path/to/file', callback) } const timeoutScheduled = Date.now(); setTimeout(() =\u0026gt; { const delay = Date.now() - timeoutScheduled console.log(`${delay}ms have passed since I was scheduled`) }, 100) // someAsyncOperation takes 95ms someAsyncOperation(() =\u0026gt; { const startCallback = Date.now() // do something will take 10ms while(Date.now() - startCallback \u0026lt; 10) { // do nothing } })  å½“äº‹ä»¶å¾ªç¯è¿›å…¥è½®è¯¢é˜¶æ®µï¼Œæ­¤æ—¶é˜Ÿåˆ—æ˜¯ç©ºçš„ï¼Œæ‰€ä»¥ä¼šç­‰å¾…ä¸€ç›´è¾¾åˆ°æœ€è¿‘çš„è®¡æ—¶å™¨é˜ˆå€¼ã€‚ 95ms åï¼Œè¯»å–æ–‡ä»¶çš„æ“ä½œå®Œæˆï¼Œå›è°ƒè¿›å…¥è½®è¯¢é˜¶æ®µçš„é˜Ÿåˆ—ï¼Œç„¶åèŠ± 10ms æ‰§è¡Œå›è°ƒã€‚æ‰§è¡Œå®Œæˆåï¼Œé˜Ÿåˆ—ä¸ºç©ºï¼Œè¿™æ—¶å€™åˆ°è¾¾äº† 100ms çš„é˜ˆå€¼ï¼Œå› æ­¤ä¼šå›åˆ° timer é˜¶æ®µæ‰§è¡Œå®šæ—¶å™¨çš„å›è°ƒã€‚æ‰€ä»¥å®šæ—¶å™¨çš„å›è°ƒä¼šåœ¨ 105ms åè¢«æ‰§è¡Œï¼Œè€Œä¸æ˜¯ 100msã€‚\n ä¸ºäº†é˜²æ­¢è½®è¯¢é˜¶æ®µè¿‡é•¿ä½¿å¾—äº‹ä»¶å¾ªç¯é™·å…¥é¥¥é¥¿ï¼Œlibuv å¯¹è½®è¯¢é˜¶æ®µè®¾ç½®å¤„ç†äº‹ä»¶çš„æœ€å¤§å€¼\n pending callbacks è¿™ä¸ªé˜¶æ®µæ‰§è¡Œç³»ç»Ÿæ“ä½œçš„å›è°ƒï¼Œæ¯”å¦‚ TCP errorã€‚æ¯”å¦‚ä¸€ä¸ª TCP è¿æ¥æ”¶åˆ°äº† ECONNREFUSED,ä¸€äº› *nix çš„ç³»ç»Ÿæƒ³è¦ report è¿™ä¸ªé”™è¯¯ã€‚è¿™äº›äº‹ä»¶çš„å›è°ƒä¼šåœ¨è¿™ä¸ªé˜¶æ®µæ‰§è¡Œã€‚\nidle prepare è¿™ä¸ªé˜¶æ®µä»…ä¾›å†…éƒ¨ä½¿ç”¨\npoll(è½®è¯¢) è½®è¯¢é˜¶æ®µä¸»è¦æœ‰ä¸¤ä¸ªåŠŸèƒ½ï¼š\n è®¡ç®—åº”è¯¥é˜»å¡å’Œè½®è¯¢ I/O çš„æ—¶é—´ å¤„ç†è½®è¯¢é˜Ÿåˆ—çš„äº‹ä»¶  å½“äº‹ä»¶å¾ªç¯è¿›å…¥ è½®è¯¢é˜¶æ®µå¹¶ä¸”æ²¡æœ‰å®šæ—¶å™¨ï¼Œå°†å‘ç”Ÿä»¥ä¸‹ä¸¤ä»¶äº‹ä¹‹ä¸€ï¼š\n å¦‚æœè½®è¯¢é˜Ÿåˆ—ä¸æ˜¯ç©ºçš„ï¼Œé‚£äº‹ä»¶å¾ªç¯ä¼šæŒ‰é¡ºåºåŒæ­¥çš„æ‰§è¡Œé˜Ÿåˆ—ä¸­çš„äº‹ä»¶ï¼ŒçŸ¥é“é˜Ÿåˆ—ä¸ºç©ºæˆ–è€…è¾¾åˆ°æœ€å¤§çš„äº‹ä»¶é™åˆ¶ å¦‚æœé˜Ÿåˆ—ä¸ºç©ºï¼Œåˆ™å¯èƒ½å‘ç”Ÿä¸‹åˆ—ä¸¤ä»¶äº‹ä¹‹ä¸€ï¼š  å¦‚æœæœ‰ setImmediate() äº‹ä»¶ï¼Œäº‹ä»¶å¾ªç¯ä¼šç»“æŸè½®è¯¢é˜¶æ®µï¼Œè¿›å…¥ check é˜¶æ®µï¼Œæ‰§è¡Œè¯¥é˜¶æ®µçš„å›è°ƒã€‚ å¦‚æœæ²¡æœ‰ setImmediate() äº‹ä»¶ï¼Œäº‹ä»¶å¾ªç¯ä¼šç­‰å¾…å›è°ƒè¢«åŠ å…¥åˆ°é˜Ÿåˆ—ï¼Œç„¶åç«‹å³æ‰§è¡Œå›è°ƒ    å¦‚æœè½®è¯¢é˜Ÿåˆ—ä¸ºç©ºï¼Œäº‹ä»¶å¾ªç¯ä¼šæ£€æŸ¥æ˜¯å¦è¾¾åˆ°å®šæ—¶å™¨çš„é˜ˆå€¼ã€‚å¦‚æœæœ‰ï¼Œäº‹ä»¶å¾ªç¯ä¼šå›åˆ° timer é˜¶æ®µï¼Œæ‰§è¡Œå®šæ—¶å™¨çš„å›è°ƒã€‚\ncheck è¿™ä¸ªé˜¶æ®µæ˜¯åœ¨è½®è¯¢é˜¶æ®µç»“æŸåæ‰§è¡Œè¯¥é˜¶æ®µçš„å›è°ƒã€‚\nsetImmediate()æ˜¯ä¸€ä¸ªç‰¹åˆ«çš„å®šæ—¶å™¨ï¼Œåœ¨å•ç‹¬çš„é˜¶æ®µæ‰§è¡Œã€‚\nä¸€èˆ¬æ¥è¯´ï¼Œä»£ç æ‰§è¡Œåï¼Œäº‹ä»¶å¾ªç¯ä¼šæœ€ç»ˆè¾¾åˆ°è½®è¯¢é˜¶æ®µï¼Œç­‰å¾…æ–°æ¥çš„é“¾æ¥ï¼Œè¯·æ±‚ç­‰ã€‚å¦‚æœæœ‰ setImmediate() è€Œä¸”è½®è¯¢é˜¶æ®µå¤„äºç©ºé—²çŠ¶æ€ï¼Œè½®è¯¢é˜¶æ®µä¼šç»“æŸï¼Œç„¶åè¿›å…¥ check é˜¶æ®µæ‰§è¡Œ setImmediate() çš„å›è°ƒã€‚\nclose callback å¦‚æœå¥—æ¥å­—æˆ–å¥æŸ„è¢«çªç„¶å…³é—­ï¼ˆä¾‹å¦‚ socket.destroy()ï¼‰,æ­¤é˜¶æ®µä¼š emit \u0026lsquo;close\u0026rsquo; äº‹ä»¶ã€‚å¦åˆ™ä¼šé€šè¿‡ process.nextTick()\nsetImmediate() VS setTimeout() setImmediate() å’Œ setTimeout() æ¯”è¾ƒç±»ä¼¼ï¼Œä½†æ˜¯æ ¹æ®è°ƒç”¨æ—¶é—´ä¸åŒè€Œæœ‰ä¸åŒçš„è¡¨ç°ã€‚\n setImmediate() è®¾è®¡ä¸º è½®è¯¢é˜¶æ®µç»“æŸåè°ƒç”¨ setTimeout() è¾¾åˆ°è®¾å®šçš„é˜ˆå€¼åè°ƒç”¨  å¦‚æœä¸¤è€…éƒ½åœ¨ä¸»æ¨¡å—ä¸­è°ƒç”¨ï¼Œé‚£ä¹ˆä¸¤è€…çš„é¡ºåºæ˜¯ä¸å›ºå®šçš„ï¼Œä¸¤è€…é¡ºåºå–å†³äºå¤„ç†å™¨çš„æ€§èƒ½ã€‚\nsetTimeout(() =\u0026gt; { console.log('timeout) }, 0) setImmediate(() =\u0026gt; { console.log('immediate) }, 0)  å¦‚æœåœ¨ I/O äº‹ä»¶ä¸­è°ƒç”¨ï¼Œåˆ™ setImmediate æ€»æ˜¯å…ˆæ‰§è¡Œ\nconst fs = require('fs'); fs.readFile(\u0026quot;\u0026quot;, () =\u0026gt; { setTimeout(() =\u0026gt; { console.log('timeout) }, 0) setImmediate(() =\u0026gt; { console.log('immediate) }, 0) })  process.nextTick() ç†è§£ nextTick process.nextTick() æ²¡æœ‰åœ¨å›¾ä¸­å±•ç¤ºï¼Œå³ä½¿è¿™æ˜¯ä¸€ä¸ªå¼‚æ­¥çš„ APIã€‚å› ä¸º nextTick ä¸å±äºäº‹ä»¶å¾ªç¯ã€‚\nåœ¨æŸä¸ªé˜¶æ®µçš„ä»»æ„æ—¶åˆ»è°ƒç”¨ process.nextTick()ï¼Œå®ƒçš„å›è°ƒä¼šåœ¨äº‹ä»¶å¾ªç¯ç»§ç»­ä¹‹å‰æ‰§è¡Œã€‚è¿™ä¼šå‡ºç°ä¸€äº›åçš„æƒ…å†µï¼Œæ¯”å¦‚åœ¨ process.nextTick() é€’å½’è°ƒç”¨ process.nextTick()ï¼Œè¿™ä¼šä½¿å¾—äº‹ä»¶å¾ªç¯æ— æ³•ç»§ç»­ã€‚\nä¸ºä»€ä¹ˆéœ€è¦ nextTick nextTick ä¸€éƒ¨åˆ†çš„è®¾è®¡ç†å¿µæ˜¯ API åº”è¯¥å§‹ç»ˆæ˜¯å¼‚æ­¥çš„ï¼Œå³ä½¿å®ƒä¸æ˜¯ã€‚ä»¥ä¸‹é¢çš„ä»£ç ä¸ºä¾‹\nfunction apiCall(arg, callback) { if (typeof arg != 'string') { return process.nextTick(callback, new TypeError('args should be string')) } }  è¿™æ ·å›è°ƒä¼šåœ¨æ‰€æœ‰ç”¨æˆ·çš„ code æ‰§è¡Œå®Œæ¯•åï¼Œåœ¨è¿›å…¥äº‹ä»¶å¾ªç¯ä¹‹å‰æ‰æ‰§è¡Œã€‚\nä¸‹é¢æ˜¯ä¸€ä¸ªçœŸæ­£çš„ä¾‹å­\nconst server = net.createServer(() =\u0026gt; {}).listen(8080) server.on('listening', () =\u0026gt; {})  åªæœ‰ç»‘å®šç«¯å£åï¼Œ \u0026lsquo;listening\u0026rsquo; å›è°ƒæ‰ä¼šæ‰§è¡Œã€‚ä½†é—®é¢˜æ˜¯é‚£æ—¶å€™ \u0026lsquo;listening\u0026rsquo; å›è°ƒè¿˜æ²¡è®¾ç½®ã€‚ æ‰€ä»¥ \u0026lsquo;listening\u0026rsquo; å›è°ƒæ”¾åœ¨ nextTick() ä¸­ã€‚\nprocess.nextTick() VS setImmediate() è¿™ä¸¤è€…æ¯”è¾ƒç±»ä¼¼ï¼Œä½†æ˜¯åå­—æœ‰ç‚¹è®©äººå›°æƒ‘\n process.nextTick() åœ¨å½“å‰é˜¶æ®µæ‰§è¡Œ setImmediate() åœ¨æ—¶é—´å¾ªç¯ä¸­æ‰§è¡Œ   å»ºè®®å¼€å‘è€…åœ¨æ‰€æœ‰æƒ…å†µä¸‹éƒ½ä½¿ç”¨ setImmediate()\n ä¸ºä»€ä¹ˆéœ€è¦ process.nextTick() ä¸»è¦æœ‰ä»¥ä¸‹ä¸¤ä¸ªåŸå› \n å…è®¸ç”¨æˆ·å¤„ç†é”™è¯¯ï¼Œæ¸…ç†ä¸éœ€è¦çš„èµ„æºæˆ–åœ¨äº‹ä»¶å¾ªç¯ä¹‹å‰å†æ¬¡å°è¯•è¯·æ±‚ æœ‰æ—¶ï¼Œéœ€è¦å…è®¸å›è°ƒåœ¨è°ƒç”¨æ ˆè§£é™¤åä½†åœ¨äº‹ä»¶å¾ªç¯ä¹‹å‰è°ƒç”¨  ä¸€ä¸ªç¬¦åˆç”¨æˆ·æœŸæœ›çš„ä¾‹å­å¦‚ä¸‹\nconst server = net.createServer(); server.on('connection', (conn) =\u0026gt; {}) server.listen(8000) server.on('listening', () =\u0026gt; {})  listen() åœ¨æ—¶é—´å¾ªç¯å¼€å§‹æ—¶å…è®¸ï¼Œå¦‚æœ \u0026lsquo;listening\u0026rsquo; å‡½æ•°æ”¾åœ¨ setImmediate ä¸­ï¼Œé‚£ä¹ˆæœ‰ä¸€å®šæ¦‚ç‡åœ¨è½®è¯¢é˜¶æ®µæ”¶åˆ°æ–°çš„è¯·æ±‚çš„æ—¶å€™ï¼Œ\u0026lsquo;listening\u0026rsquo; å›è°ƒè¿˜æ²¡æœ‰æ³¨å†Œã€‚\nå¦ä¸€ä¸ªä¾‹å­æ˜¯åœ¨æ„é€ å‡½æ•°ä¸­ emit äº‹ä»¶\nconst EventEmitter = require('events') const util = require('util') function MyEmitter() { EventEmitter.call(this) this.emit('event) } util.inherits(MyEmitter, EventEmitter) const myEmitter = new MyEmitter(); myEmitter.on('event', () =\u0026gt; { console.log('event occurred!') })  ä¸Šè¯‰ä»£ç ä¸­çš„äº‹ä»¶ä¸ä¼šè§¦å‘ï¼Œå› ä¸ºè„šæœ¬ä¸ä¼šå¤„ç†åˆ°ä¸ºäº‹ä»¶åˆ†é…å›è°ƒçš„åœ°æ–¹ã€‚å¦‚æœå°† this.emit(\u0026lsquo;event) æ”¾å…¥ process.nextTick() ä¸­æ‰§è¡Œï¼Œåˆ™ä¼šè§¦å‘ \u0026lsquo;event\u0026rsquo; äº‹ä»¶ã€‚\n","id":1,"section":"posts","summary":"ä¸ºä»€ä¹ˆè¦å†™è¿™ç¯‡æ–‡ç«  æœ‰ä¸€æ®µæ—¶é—´ nodejs å·¥ä½œç»å†ï¼Œé¢è¯•æ€»æ˜¯è¢«é—®åˆ° Event Loop,è™½ç„¶çœ‹è¿‡å®˜ç½‘ä¸Šçš„æ–‡ç« ï¼Œå¥ˆä½•æ€»æ˜¯è®°ä¸ä½ï¼Œé¢è¯•ä¹Ÿç­”ä¸ä¸Šæ¥ã€‚å› æ­¤ï¼Œå†™è¿™ç¯‡æ–‡ç« æ¥åŠ ","tags":null,"title":"The Node.js Event Loop, Timers and process.nextTick()","uri":"https://fearlessfe.github.io/blog/2022/02/event-loop/","year":"2022"},{"content":"Mutex æ¶æ„æ¼”è¿›æ–¹å‘ golang ä¸­çš„ Mutex æ˜¯äº’æ–¥é”ï¼Œå®ƒçš„å®ç°ä¸æ˜¯ä¸€æˆä¸å˜çš„ï¼Œä¸»è¦ç»å†äº†ä»¥ä¸‹çš„å˜åŒ–\n åˆç‰ˆï¼šä½¿ç”¨ flag æ ‡è®°å­—æ®µæ˜¯å¦æœ‰é” ç»™æ–°äººæœºä¼šï¼šæ–°çš„ goroutine ä¹Ÿæœ‰æœºä¼šç«äº‰é” å¤šç»™äº›æœºä¼šï¼šæ–°æ¥çš„å’Œè¢«å”¤é†’çš„æœ‰æ›´å¤šæœºä¼šç«äº‰ è§£å†³é¥¥é¥¿ï¼šè§£å†³ç«äº‰é—®é¢˜ï¼Œä¸è®© goroutine ä¸€ç›´ç­‰å¾…  åˆç‰ˆäº’æ–¥é” åˆç‰ˆäº’æ–¥é”ä½¿ç”¨ CAS æŒ‡ä»¤å®ç°ï¼Œä»¥ä¸‹ä»£ç ä¸º Mutex çš„åˆç‰ˆå®ç°ã€‚\n CAS æŒ‡ä»¤å°†ç»™å®šçš„å€¼å’Œä¸€ä¸ªå†…å­˜åœ°å€ä¸­çš„å€¼è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœæ˜¯åŒä¸€ä¸ªå€¼ï¼Œå°±ç”¨æ–°çš„å€¼æ›¿æ¢å†…å­˜ä¸­çš„å€¼ã€‚\n // CASæ“ä½œ func cas(val *int32, old, new int32) bool func semacquire(*int32) func semrelease(*int32) // äº’æ–¥é”ç»“æ„ type Mutex struct { key int32 // é”æ˜¯å¦è¢«æŒæœ‰çš„flag sema int32 // ä¿¡å·é‡ï¼Œç”¨æ¥é˜»å¡/å”¤é†’goroutine } func xadd(val *int32, delta int32) (new int32) { for { v := val if cas(val, v, v + delta) { return v + delta } } panic(\u0026quot;unreached\u0026quot;) } func (m *Mutex) Lock() { if xadd(\u0026amp;m.key, 1) == 1 { return } semacquire(\u0026amp;m.sema) // è¿›å…¥é˜Ÿåˆ— } func (m *Mutex) Unlock() { if xadd(\u0026amp;m.key, -1) == 0 { return } semrelease(\u0026amp;m.sema) // å”¤é†’é˜Ÿåˆ—ä¸­çš„goroutine }  åˆç‰ˆå®ç°é€šè¿‡ Mutex çš„ key å±æ€§ä½œä¸ºæ ‡è¯†ï¼Œkey ä¸º0æˆ–1æ¥è¡¨ç¤ºé”æ˜¯å¦è¢«å ç”¨ã€‚\nUnlock æ–¹æ³•å¯ä»¥è¢«ä»»æ„çš„ goroutine è°ƒç”¨ï¼Œå³ä½¿æ˜¯æ²¡æœ‰æŒæœ‰è¿™ä¸ªé”çš„ goroutineã€‚æ‰€ä»¥ä½¿ç”¨ Mutex æ—¶ï¼Œä¸€å®šè¦éµå¾ªâ€œè°ç”³è¯·ï¼Œè°é‡Šæ”¾â€çš„åŸåˆ™ã€‚\nè¿™ç§å®ç°æ–¹å¼ï¼ŒæŒ‰ç…§ FIFO çš„æ–¹å¼æ¥è·å–é”ã€‚ä½†æ˜¯åœ¨é«˜å¹¶å‘çš„æƒ…å†µä¸‹ï¼Œä¼šé¢‘ç¹çš„åˆ‡æ¢ä¸Šä¸‹æ–‡ï¼Œæ€§èƒ½ä¼šæœ‰æŸè€—ã€‚å¦‚æœèƒ½å¤Ÿå°†é”äº¤ç»™æ­£åœ¨å ç”¨ CPU æ—¶é—´ç‰‡çš„ goroutine çš„è¯ï¼Œä¼šæœ‰æ›´å¥½çš„æ€§èƒ½ã€‚\nç»™æ–°äººæœºä¼š è¿™ä¸€ç‰ˆå°è¯•ç»™æ–°æ¥çš„ goroutine è·å–é”çš„æœºä¼šã€‚\ntype Mutex struct { state int32 sema uint32 } // 32ä½ state æ˜¯å¤åˆå­—æ®µã€‚æœ€å°çš„ä¸€ä½è¡¨ç¤ºé”æ˜¯å¦å æœ‰ï¼Œç¬¬äºŒä½è¡¨ç¤ºæ˜¯å¦æœ‰å”¤é†’çš„ goroutineï¼Œå‰©ä¸‹çš„ä»£è¡¨ç­‰å¾…è¯¥é”çš„ goroutine æ•°é‡ const ( mutexLocked = 1 \u0026lt;\u0026lt; iota // 1 mutexWoken // 2 mutexWaiterShift = iota // 2 ) func (m *Mutex) Lock() { // state ä¸º 0,ç›´æ¥è·å–é” if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { return } awoke := false for { old := m.state new := old | mutexLocked // è®¾ç½®åŠ é”çš„çŠ¶æ€ // old ä¸ºæœ‰é”çš„çŠ¶æ€ï¼Œç­‰å¾…è€…åŠ 1 if old \u0026amp; mutexLocked != 0 { new = old + 1 \u0026lt;\u0026lt; mutexWaiterShift } if awoke { // goroutine æ˜¯è¢«å”¤é†’ // å°† mutexWoken æ ‡å¿—ä½å˜ä¸º0 new = new \u0026amp;^ mutexWoken } if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { // æ— é”çŠ¶æ€ï¼Œç›´æ¥è·å–é” if old \u0026amp; mutexLocked == 0 { break } runtime.Semacquire(\u0026amp;m.sema) // ä¼‘çœ  awoke = true // å”¤é†’åï¼Œawokeè®¾ç½®ä¸ºtrue } } }  è¯·æ±‚é”çš„ goroutine åˆ†ä¸ºæ–°æ¥çš„å’Œè¢«å”¤é†’çš„ï¼Œä¸¤è€…éƒ½ä¼šå°è¯•è·å–é”ã€‚ä¸¤è€…çš„åŒºåˆ«è§ä¸‹è¡¨\n   è¯·æ±‚é” é”è¢«æŒæœ‰ é”æœªè¢«æŒæœ‰     æ–°æ¥çš„goroutine waiter++ ä¼‘çœ  è·å–é”   è¢«å”¤é†’çš„goroutine æ¸…é™¤mutexWokenï¼ŒåŠ å…¥ç­‰å¾…é˜Ÿåˆ— æ¸…é™¤mutexWokenï¼Œè·å–é”    func (m *Mutex) Unlock() { new := atomic.AddInt32(\u0026amp;m.state, -mutexLocked) // å»æ‰é”æ ‡å¿— if (new + mutexLocked) \u0026amp; mutexLocked == 0 { // unlock of unclocked mutex panic(\u0026quot;....\u0026quot;) } old := new for { // æ²¡æœ‰ç­‰å¾…è€… æˆ– (å”¤é†’çŠ¶æ€çš„goroutineæˆ–æœ‰é”) if old\u0026gt;\u0026gt;mutexWaiterShift == 0 || old\u0026amp;(mutexLocked|mutexWoken) != 0 { return } // ç­‰å¾…è€…å‡1ï¼Œå”¤é†’æ ‡å¿—ä½è®¾ä¸º1 new = (old - 1\u0026lt;\u0026lt;mutexWaiterShift) | mutexWoken if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { runtime.Semrelease(\u0026amp;m.sema) return } old = m.state } }  é‡Šæ”¾é”æ—¶ï¼Œé¦–å…ˆä¼šå°†å»æ‰é”çš„æ ‡å¿—ä½ã€‚å¦‚æœå·²ç»æ˜¯é‡Šæ”¾çš„çŠ¶æ€ï¼Œåˆ™ç›´æ¥panicã€‚ è¿›å…¥ for å¾ªç¯åï¼Œ å¦‚æœæ²¡æœ‰ç­‰å¾…è€…ï¼Œreturn å¦‚æœç°åœ¨æœ‰å”¤é†’çš„ goroutine æˆ–è€…æŒæœ‰é”çš„ goroutineï¼Œç›´æ¥äº¤ç»™å…¶ä½™çš„ goroutine å¤„ç†ï¼Œreturn\nå°†ç­‰å¾…è€…å‡1ï¼Œè®¾ç½®å”¤é†’æ ‡å¿—ä½ï¼Œç„¶åå”¤é†’ç­‰å¾…çš„ goroutine.\nè¿™ä¸€ç‰ˆæœ¬çš„å®ç°ï¼Œè®©æ–°æ¥çš„ goroutine å’Œå”¤é†’çš„ goroutine ç«äº‰ï¼Œä½¿å¾—æ–°æ¥çš„ goroutine å¯ä»¥è·å–é”ï¼Œè¿™æ ·å¯ä»¥å‡å°‘ä¸Šä¸‹æ–‡çš„åˆ‡æ¢ï¼Œæå‡æ€§èƒ½ã€‚\nå¤šç»™äº›æœºä¼š æ–°æ¥çš„ goroutine å’Œå”¤é†’çš„ goroutine å¦‚æœæ²¡æœ‰è·å–åˆ°é”ï¼Œä¼šé€šè¿‡è‡ªæ—‹çš„æ–¹å¼ï¼Œå°è¯•æ£€æŸ¥é”æ˜¯å¦è¢«é‡Šæ”¾ã€‚ç»è¿‡ä¸€å®šæ¬¡æ•°çš„å°è¯•åï¼Œå†æ‰§è¡ŒåŸæ¥çš„æ“ä½œã€‚æ”¹åŠ¨åçš„ Lock å®ç°å¦‚ä¸‹\nfunc (m *Mutex) Lock() { // state ä¸º 0,ç›´æ¥è·å–é” if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { return } awoke := false iter := 0 for { old := m.state new := old | mutexLocked if old \u0026amp; mutexLocked != 0 { if runtime_canSpin(iter) { // æ–°çš„goroutine \u0026amp;\u0026amp; æ²¡æœ‰å”¤é†’çš„goroutine \u0026amp;\u0026amp; æœ‰ç­‰å¾…è€… \u0026amp;\u0026amp; è®¾ç½®mutexWokenæ ‡å¿—ä½ if !awoke \u0026amp;\u0026amp; old\u0026amp;mutexWoken == 0 \u0026amp;\u0026amp; old\u0026gt;\u0026gt;mutexWaiterShift != 0 \u0026amp;\u0026amp; atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken) { awoke = true // è®¾ç½® mutexWoken æ ‡å¿—ä½åï¼ŒUnlock æ–¹æ³•ä¸ä¼šå”¤é†’æ–°çš„ goroutineï¼Œè‡ªé€‰æœŸé—´è·å–é”çš„æ¦‚ç‡å˜å¤§ } runtime_doSpin() iter++ continue } // è‡ªæ—‹ç»“æŸï¼Œç­‰å¾…åˆ—è¡¨åŠ 1 new = old + 1\u0026lt;\u0026lt;mutexWaiterShift } if awoke { if new\u0026amp;mutexWoken == 0 { panic(\u0026quot;sync: inconsistent mutex state\u0026quot;) } new \u0026amp;^ = mutexWoken // æ–°çŠ¶æ€æ¸…é™¤å”¤é†’æ ‡è®° } if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { if old\u0026amp;mutexLocked == 0 { break } runtime_Semacquire(\u0026amp;m.sema) awoke = true iter = 0 } } }  ä¸Šé¢è‡ªæ—‹æ—¶ï¼Œä¼šè®¾ç½®å”¤é†’æ ‡å¿—ä½ï¼Œå¯¼è‡´ç­‰å¾…é˜Ÿåˆ—çš„goroutineå¯èƒ½ä¸€ç›´å¤„äºä¼‘çœ çŠ¶æ€ï¼Œè¿™æ ·ä¼šäº§ç”Ÿé¥¥é¥¿çš„é—®é¢˜ã€‚\nè§£å†³é¥¥é¥¿ type Mutex struct { state int32 sema uint32 } const ( mutexLocked = 1 \u0026lt;\u0026lt; iota // 1 mutexWoken // 2 mutexStarving // 4 mutexWaiterShift = iota // 3 starvationThresholdNs = 1e6 // 1ms ) func (m *Mutex) Lock() { if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { return } // Slow path m.lockSlow() } func (m *Mutex) lockSlow() { var waitStartTime int64 starving := false awoke := false iter := 0 old := m.state for { // é”æœªé‡Šæ”¾ï¼Œä¸”ä¸å¤„äºé¥¥é¥¿çŠ¶æ€ã€‚ å¯ä»¥è‡ªxuan if old\u0026amp;(mutexLocked|mutexStarving) == mutexLocked \u0026amp;\u0026amp; runtime_canSpin(iter) { if runtime_canSpin(iter) { if !awoke \u0026amp;\u0026amp; old\u0026amp;mutexWoken == 0 \u0026amp;\u0026amp; old\u0026gt;\u0026gt;mutexWaiterShift != 0 \u0026amp;\u0026amp; atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken) { // æ–°çš„goroutine \u0026amp;\u0026amp; æ²¡æœ‰å”¤é†’çš„goroutine \u0026amp;\u0026amp; æœ‰ç­‰å¾… \u0026amp;\u0026amp; å°†å½“å‰giroutineè®¾ä¸ºå”¤é†’çŠ¶æ€ awoke = true } runtime_doSpin() iter++ old = m.state // è·å–é”çš„çŠ¶æ€ï¼Œä¹‹åä¼šæ£€æŸ¥é”æ˜¯å¦é‡Šæ”¾ continue } new := old // éé¥¥é¥¿æ¨¡å¼ï¼ŒåŠ é” if old\u0026amp;mutexStarving == 0 { new |= mutexLocked } // é¥¥é¥¿æ¨¡å¼æˆ–è€…æœ‰é” if old\u0026amp;(mutexLocked|mutexStarving) != 0 { new += 1\u0026lt;\u0026lt;mutexWaiterShift } // æœ‰é”ï¼Œè®¾ç½®é¥¥é¥¿æ¨¡å¼ if starving \u0026amp;\u0026amp; old\u0026amp;mutexLocked != 0 { new |= mutexStarving } if awoke { if new\u0026amp;mutexWoken == 0 { throw(\u0026quot;sync: inconsistent mutex state\u0026quot;) } new \u0026amp;^ = mutexWoken } if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { // æ— é”ï¼Œéé¥¥é¥¿æ¨¡å¼ if old\u0026amp;(mutexLocked|mutexStarving) == 0 { break } // å¤„ç†é¥¥é¥¿çŠ¶æ€ // å¦‚æœä»¥å‰å°±åœ¨é˜Ÿåˆ—é‡Œï¼ŒåŠ å…¥åˆ°é˜Ÿåˆ—å¤´ queueLifo := waitStartTime != 0 if waitStartTime == 0 { waitStartTime = runtime_nanotime() } // é˜»å¡ç­‰å¾… runtime_Semacquire(\u0026amp;m.sema, queueLifo, 1) starving = starving || runtime_nanotime()-waitStartTime \u0026gt; starvationThresholdNs old = m.state // å¦‚æœé”å·²ç»å¤„äºé¥¥é¥¿çŠ¶æ€ï¼Œç›´æ¥æŠ¢åˆ°é”ï¼Œè¿”å› if old\u0026amp;mutexStarving != 0 { if old\u0026amp;(mutexLocked|mutexWoken) != 0 || old\u0026gt;\u0026gt;mutexWaiterShift == 0 { throw(\u0026quot;sync: inconsistent mutex state\u0026quot;) } // åŠ é”ä¸”å°†waiterå‡1 delta := int32(mutexLocked - 1\u0026lt;\u0026lt;mutexWaiterShift) if !starving || old\u0026gt;\u0026gt;mutexWaiterShift == 1 { delta -= mutexStarving // æœ€åä¸€ä¸ªwaiteræˆ–è€…å·²ç»ä¸é¥¥é¥¿ï¼Œæ¸…é™¤æ ‡è®° } atmoc.AddInt32(\u0026amp;m.state, delta) break } awoke = true iter = 0 } } else { old = m.state } } }  ","id":2,"section":"posts","summary":"Mutex æ¶æ„æ¼”è¿›æ–¹å‘ golang ä¸­çš„ Mutex æ˜¯äº’æ–¥é”ï¼Œå®ƒçš„å®ç°ä¸æ˜¯ä¸€æˆä¸å˜çš„ï¼Œä¸»è¦ç»å†äº†ä»¥ä¸‹çš„å˜åŒ– åˆç‰ˆï¼šä½¿ç”¨ flag æ ‡è®°å­—æ®µæ˜¯å¦æœ‰é” ç»™æ–°äººæœºä¼šï¼šæ–°çš„ goroutine ä¹Ÿæœ‰æœºä¼šç«äº‰é” å¤šç»™","tags":null,"title":"Golang Mutex æºç è§£æ","uri":"https://fearlessfe.github.io/blog/2022/01/mutex/","year":"2022"}],"tags":[]}