{"categories":[],"posts":[{"content":"最近面试 golang 被问到，golang 里面的 mutex 是什么类型的锁。很无奈，没了解过相关知识，没有答出来。\n在 google 上一搜，对 Java 中锁介绍的资料最多，从不同的角度出发，锁的分类也不同。下图引用了美图技术博客的分类\n下面对其中的几类锁做一下简单的介绍，然后看看 mutex 是什么类型的锁。\n乐观锁，悲观锁 乐观锁和悲观锁是以是否锁住同步资源来区分的。\n很显然，mutex 是悲观锁，goroutine 获取锁后，相关的资源也会锁住，不让其余 goroutine 操作。\n那么乐观锁是怎么处理多个 goroutine 的竞争关系呢？答案就是 CAS（Campare And Swap），先比较，再交换。 go里面的 atomic 包提供了相关方法,以 CompareAndSwapInt32 为例，该方法接受3个参数：\n 内存地址,addr 需要比较的值,old 新的值,new  将 addr 处的值于 old 比较，如果相同，则将 addr 的值设置为 new，否则就返回 false。\natomic.CompareAndSwapInt32(\u0026amp;addr, old, new)  CAS 的性能会远高于锁，但是 CAS 也会有一些不适用的情况。\n ABA 问题：CAS 只是比较值是否改变，如果该地址初始值为 A，别的 goroutine 将值改为 B，后来🈶️有 goroutine 将值改为 A。CAS 是不能判断这种变化的，可能会产生一些问题。 只能对一个变量进行操作，无法保证多个变量的原子性。  除了 CAS，使用版本号也可以实现乐观锁。\n版本号的原理是在数据中加一个 version 字段，每次字段改变后， version 加 1。每次更新时，先比较当前版本于数据目前的版本是否一致，否则就不能更新数据。\n公平锁，非公平锁 按照多个 goroutine 竞争锁的时候，是否按照 FIFO 的顺序来获得锁，可以分为公平锁和非公平锁。\nmutex 的实现经历了多个版本，早期版本时按照 FIFO 的方式来实现的，是公平锁。但后来的版本为了性能，该为了非公平锁。详细资料可参考相关文章。\n目前 mutex 的实现是新的 goroutine 进来会先插队，插队失败后会排队。所以 mutex 是非公平锁。\n其余类型 mutex 是互斥锁，只能由单个 gouroutine 获取，而且不能重复的去获取同一把锁。所以 mutex 是不可重入锁，排它锁。\n总结 mutex 可以是 悲观锁，非公平锁，不可重入锁和排它锁。\n参考资料 【BAT面试题系列】面试官：你了解乐观锁和悲观锁吗？\n不可不说的Java“锁”事\n","id":0,"section":"posts","summary":"最近面试 golang 被问到，golang 里面的 mutex 是什么类型的锁。很无奈，没了解过相关知识，没有答出来。 在 google 上一搜，对 Java 中锁介绍的资料最多，从不同的角度","tags":null,"title":"golang 里面的 mutex 是什么类型的锁？","uri":"https://fearlessfe.github.io/blog/2022/02/%E6%82%B2%E8%A7%82%E9%94%81%E4%B9%90%E8%A7%82%E9%94%81/","year":"2022"},{"content":"为什么要写这篇文章 有一段时间 nodejs 工作经历，面试总是被问到 Event Loop,虽然看过官网上的文章，奈何总是记不住，面试也答不上来。因此，写这篇文章来加深印象。原文请👇这里\n什么是 Event Loop 虽然 Javascript 是单线程的，但是 Event Loop 让 Nodejs 能够执行非阻塞的 I/O。\n现代内核都是多线程的，它们可在后台执行多个操作。但其中一个操作完成后，内核通知 Nodejs 以便将相应的回调添加到轮询队列，最后回调会被执行。\nEvent Loop简介 当 Nodejs 运行时，它会初始化事件循环，执行输入的脚本，脚本中可能会调用异步的 API，timer 函数或 process.nextTick(),然后开始事件循环。\n下图（来源于原文）简单的描述了事件循环操作顺序。\n┌───────────────────────────┐ ┌─\u0026gt;│ timers │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ pending callbacks │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ idle, prepare │ │ └─────────────┬─────────────┘ ┌───────────────┐ │ ┌─────────────┴─────────────┐ │ incoming: │ │ │ poll │\u0026lt;─────┤ connections, │ │ └─────────────┬─────────────┘ │ data, etc. │ │ ┌─────────────┴─────────────┐ └───────────────┘ │ │ check │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ └──┤ close callbacks │ └───────────────────────────┘\n 图中每个盒子代表事件循环中一个阶段\n 每个阶段都是一个队列，按照 FIFO 的方式执行回调函数。事件循环进入其中一个阶段后，首先会执行该阶段特定的操作。然后执行该阶段队列中的回调，知道队列中回调全部执行完或者达到最大的回调限制，然后事件循环进入下一个阶段。\n由于这些操作可能会产生新的事件，而轮询阶段（poll phase）新的事件由内核加入到队列，因此处理轮询事件时也会有新的事件加入到队列中。因此，长时间运行的回调会让轮询阶段的时间远超过计时器的阈值。\n阶段概览  timers: 这个阶段执行 setTimeout() 和 setInterval() 的回调 pending callbacks：执行推迟到下一个循环的 I/O 回调 idle,prepare: 仅供内部使用 poll（轮询）: 检索新的 I/O 事件；执行 I/O 相关的回调（几乎所有的回调，除了关闭回调，定时器调度的回调和setImmediate()）,节点会在适当的时候阻塞。 check：setImmediate()的回调在这里执行。 close callbacks: 关闭的回调，比如socket.on('close',...)  在事件循环之间，Nodejs 会检查它是否正在等待异步 I/O 或计时器。如果没有，则退出。（这里退出应该是指退出 nodejs 程序）。\n阶段详情 timers 计时器可以指定一个阈值，到达阈值后执行回调，而不是决定回调执行的确切时间。计时器的回调会在指定的时间过后尽可能早的执行，但是回调的执行可能会延迟。\n 轮询阶段控制计时器回调的执行\n 举个例子，定时器在100ms后执行回调，然后一个异步读取文件会花 95ms\nconst fs = require('fs'); function someAsyncOperation(callback) { fs.readFile('/path/to/file', callback) } const timeoutScheduled = Date.now(); setTimeout(() =\u0026gt; { const delay = Date.now() - timeoutScheduled console.log(`${delay}ms have passed since I was scheduled`) }, 100) // someAsyncOperation takes 95ms someAsyncOperation(() =\u0026gt; { const startCallback = Date.now() // do something will take 10ms while(Date.now() - startCallback \u0026lt; 10) { // do nothing } })  当事件循环进入轮询阶段，此时队列是空的，所以会等待一直达到最近的计时器阈值。 95ms 后，读取文件的操作完成，回调进入轮询阶段的队列，然后花 10ms 执行回调。执行完成后，队列为空，这时候到达了 100ms 的阈值，因此会回到 timer 阶段执行定时器的回调。所以定时器的回调会在 105ms 后被执行，而不是 100ms。\n 为了防止轮询阶段过长使得事件循环陷入饥饿，libuv 对轮询阶段设置处理事件的最大值\n pending callbacks 这个阶段执行系统操作的回调，比如 TCP error。比如一个 TCP 连接收到了 ECONNREFUSED,一些 *nix 的系统想要 report 这个错误。这些事件的回调会在这个阶段执行。\nidle prepare 这个阶段仅供内部使用\npoll(轮询) 轮询阶段主要有两个功能：\n 计算应该阻塞和轮询 I/O 的时间 处理轮询队列的事件  当事件循环进入 轮询阶段并且没有定时器，将发生以下两件事之一：\n 如果轮询队列不是空的，那事件循环会按顺序同步的执行队列中的事件，知道队列为空或者达到最大的事件限制 如果队列为空，则可能发生下列两件事之一：  如果有 setImmediate() 事件，事件循环会结束轮询阶段，进入 check 阶段，执行该阶段的回调。 如果没有 setImmediate() 事件，事件循环会等待回调被加入到队列，然后立即执行回调    如果轮询队列为空，事件循环会检查是否达到定时器的阈值。如果有，事件循环会回到 timer 阶段，执行定时器的回调。\ncheck 这个阶段是在轮询阶段结束后执行该阶段的回调。\nsetImmediate()是一个特别的定时器，在单独的阶段执行。\n一般来说，代码执行后，事件循环会最终达到轮询阶段，等待新来的链接，请求等。如果有 setImmediate() 而且轮询阶段处于空闲状态，轮询阶段会结束，然后进入 check 阶段执行 setImmediate() 的回调。\nclose callback 如果套接字或句柄被突然关闭（例如 socket.destroy()）,此阶段会 emit \u0026lsquo;close\u0026rsquo; 事件。否则会通过 process.nextTick()\nsetImmediate() VS setTimeout() setImmediate() 和 setTimeout() 比较类似，但是根据调用时间不同而有不同的表现。\n setImmediate() 设计为 轮询阶段结束后调用 setTimeout() 达到设定的阈值后调用  如果两者都在主模块中调用，那么两者的顺序是不固定的，两者顺序取决于处理器的性能。\nsetTimeout(() =\u0026gt; { console.log('timeout) }, 0) setImmediate(() =\u0026gt; { console.log('immediate) }, 0)  如果在 I/O 事件中调用，则 setImmediate 总是先执行\nconst fs = require('fs'); fs.readFile(\u0026quot;\u0026quot;, () =\u0026gt; { setTimeout(() =\u0026gt; { console.log('timeout) }, 0) setImmediate(() =\u0026gt; { console.log('immediate) }, 0) })  process.nextTick() 理解 nextTick process.nextTick() 没有在图中展示，即使这是一个异步的 API。因为 nextTick 不属于事件循环。\n在某个阶段的任意时刻调用 process.nextTick()，它的回调会在事件循环继续之前执行。这会出现一些坏的情况，比如在 process.nextTick() 递归调用 process.nextTick()，这会使得事件循环无法继续。\n为什么需要 nextTick nextTick 一部分的设计理念是 API 应该始终是异步的，即使它不是。以下面的代码为例\nfunction apiCall(arg, callback) { if (typeof arg != 'string') { return process.nextTick(callback, new TypeError('args should be string')) } }  这样回调会在所有用户的 code 执行完毕后，在进入事件循环之前才执行。\n下面是一个真正的例子\nconst server = net.createServer(() =\u0026gt; {}).listen(8080) server.on('listening', () =\u0026gt; {})  只有绑定端口后， \u0026lsquo;listening\u0026rsquo; 回调才会执行。但问题是那时候 \u0026lsquo;listening\u0026rsquo; 回调还没设置。 所以 \u0026lsquo;listening\u0026rsquo; 回调放在 nextTick() 中。\nprocess.nextTick() VS setImmediate() 这两者比较类似，但是名字有点让人困惑\n process.nextTick() 在当前阶段执行 setImmediate() 在时间循环中执行   建议开发者在所有情况下都使用 setImmediate()\n 为什么需要 process.nextTick() 主要有以下两个原因\n 允许用户处理错误，清理不需要的资源或在事件循环之前再次尝试请求 有时，需要允许回调在调用栈解除后但在事件循环之前调用  一个符合用户期望的例子如下\nconst server = net.createServer(); server.on('connection', (conn) =\u0026gt; {}) server.listen(8000) server.on('listening', () =\u0026gt; {})  listen() 在时间循环开始时允许，如果 \u0026lsquo;listening\u0026rsquo; 函数放在 setImmediate 中，那么有一定概率在轮询阶段收到新的请求的时候，\u0026lsquo;listening\u0026rsquo; 回调还没有注册。\n另一个例子是在构造函数中 emit 事件\nconst EventEmitter = require('events') const util = require('util') function MyEmitter() { EventEmitter.call(this) this.emit('event) } util.inherits(MyEmitter, EventEmitter) const myEmitter = new MyEmitter(); myEmitter.on('event', () =\u0026gt; { console.log('event occurred!') })  上诉代码中的事件不会触发，因为脚本不会处理到为事件分配回调的地方。如果将 this.emit(\u0026lsquo;event) 放入 process.nextTick() 中执行，则会触发 \u0026lsquo;event\u0026rsquo; 事件。\n","id":1,"section":"posts","summary":"为什么要写这篇文章 有一段时间 nodejs 工作经历，面试总是被问到 Event Loop,虽然看过官网上的文章，奈何总是记不住，面试也答不上来。因此，写这篇文章来加","tags":null,"title":"The Node.js Event Loop, Timers and process.nextTick()","uri":"https://fearlessfe.github.io/blog/2022/02/event-loop/","year":"2022"},{"content":"Mutex 架构演进方向 golang 中的 Mutex 是互斥锁，它的实现不是一成不变的，主要经历了以下的变化\n 初版：使用 flag 标记字段是否有锁 给新人机会：新的 goroutine 也有机会竞争锁 多给些机会：新来的和被唤醒的有更多机会竞争 解决饥饿：解决竞争问题，不让 goroutine 一直等待  初版互斥锁 初版互斥锁使用 CAS 指令实现，以下代码为 Mutex 的初版实现。\n CAS 指令将给定的值和一个内存地址中的值进行比较，如果是同一个值，就用新的值替换内存中的值。\n // CAS操作 func cas(val *int32, old, new int32) bool func semacquire(*int32) func semrelease(*int32) // 互斥锁结构 type Mutex struct { key int32 // 锁是否被持有的flag sema int32 // 信号量，用来阻塞/唤醒goroutine } func xadd(val *int32, delta int32) (new int32) { for { v := val if cas(val, v, v + delta) { return v + delta } } panic(\u0026quot;unreached\u0026quot;) } func (m *Mutex) Lock() { if xadd(\u0026amp;m.key, 1) == 1 { return } semacquire(\u0026amp;m.sema) // 进入队列 } func (m *Mutex) Unlock() { if xadd(\u0026amp;m.key, -1) == 0 { return } semrelease(\u0026amp;m.sema) // 唤醒队列中的goroutine }  初版实现通过 Mutex 的 key 属性作为标识，key 为0或1来表示锁是否被占用。\nUnlock 方法可以被任意的 goroutine 调用，即使是没有持有这个锁的 goroutine。所以使用 Mutex 时，一定要遵循“谁申请，谁释放”的原则。\n这种实现方式，按照 FIFO 的方式来获取锁。但是在高并发的情况下，会频繁的切换上下文，性能会有损耗。如果能够将锁交给正在占用 CPU 时间片的 goroutine 的话，会有更好的性能。\n给新人机会 这一版尝试给新来的 goroutine 获取锁的机会。\ntype Mutex struct { state int32 sema uint32 } // 32位 state 是复合字段。最小的一位表示锁是否占有，第二位表示是否有唤醒的 goroutine，剩下的代表等待该锁的 goroutine 数量 const ( mutexLocked = 1 \u0026lt;\u0026lt; iota // 1 mutexWoken // 2 mutexWaiterShift = iota // 2 ) func (m *Mutex) Lock() { // state 为 0,直接获取锁 if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { return } awoke := false for { old := m.state new := old | mutexLocked // 设置加锁的状态 // old 为有锁的状态，等待者加1 if old \u0026amp; mutexLocked != 0 { new = old + 1 \u0026lt;\u0026lt; mutexWaiterShift } if awoke { // goroutine 是被唤醒 // 将 mutexWoken 标志位变为0 new = new \u0026amp;^ mutexWoken } if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { // 无锁状态，直接获取锁 if old \u0026amp; mutexLocked == 0 { break } runtime.Semacquire(\u0026amp;m.sema) // 休眠 awoke = true // 唤醒后，awoke设置为true } } }  请求锁的 goroutine 分为新来的和被唤醒的，两者都会尝试获取锁。两者的区别见下表\n   请求锁 锁被持有 锁未被持有     新来的goroutine waiter++ 休眠 获取锁   被唤醒的goroutine 清除mutexWoken，加入等待队列 清除mutexWoken，获取锁    func (m *Mutex) Unlock() { new := atomic.AddInt32(\u0026amp;m.state, -mutexLocked) // 去掉锁标志 if (new + mutexLocked) \u0026amp; mutexLocked == 0 { // unlock of unclocked mutex panic(\u0026quot;....\u0026quot;) } old := new for { // 没有等待者 或 (唤醒状态的goroutine或有锁) if old\u0026gt;\u0026gt;mutexWaiterShift == 0 || old\u0026amp;(mutexLocked|mutexWoken) != 0 { return } // 等待者减1，唤醒标志位设为1 new = (old - 1\u0026lt;\u0026lt;mutexWaiterShift) | mutexWoken if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { runtime.Semrelease(\u0026amp;m.sema) return } old = m.state } }  释放锁时，首先会将去掉锁的标志位。如果已经是释放的状态，则直接panic。 进入 for 循环后， 如果没有等待者，return 如果现在有唤醒的 goroutine 或者持有锁的 goroutine，直接交给其余的 goroutine 处理，return\n将等待者减1，设置唤醒标志位，然后唤醒等待的 goroutine.\n这一版本的实现，让新来的 goroutine 和唤醒的 goroutine 竞争，使得新来的 goroutine 可以获取锁，这样可以减少上下文的切换，提升性能。\n多给些机会 新来的 goroutine 和唤醒的 goroutine 如果没有获取到锁，会通过自旋的方式，尝试检查锁是否被释放。经过一定次数的尝试后，再执行原来的操作。改动后的 Lock 实现如下\nfunc (m *Mutex) Lock() { // state 为 0,直接获取锁 if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { return } awoke := false iter := 0 for { old := m.state new := old | mutexLocked if old \u0026amp; mutexLocked != 0 { if runtime_canSpin(iter) { // 新的goroutine \u0026amp;\u0026amp; 没有唤醒的goroutine \u0026amp;\u0026amp; 有等待者 \u0026amp;\u0026amp; 设置mutexWoken标志位 if !awoke \u0026amp;\u0026amp; old\u0026amp;mutexWoken == 0 \u0026amp;\u0026amp; old\u0026gt;\u0026gt;mutexWaiterShift != 0 \u0026amp;\u0026amp; atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken) { awoke = true // 设置 mutexWoken 标志位后，Unlock 方法不会唤醒新的 goroutine，自选期间获取锁的概率变大 } runtime_doSpin() iter++ continue } // 自旋结束，等待列表加1 new = old + 1\u0026lt;\u0026lt;mutexWaiterShift } if awoke { if new\u0026amp;mutexWoken == 0 { panic(\u0026quot;sync: inconsistent mutex state\u0026quot;) } new \u0026amp;^ = mutexWoken // 新状态清除唤醒标记 } if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { if old\u0026amp;mutexLocked == 0 { break } runtime_Semacquire(\u0026amp;m.sema) awoke = true iter = 0 } } }  上面自旋时，会设置唤醒标志位，导致等待队列的goroutine可能一直处于休眠状态，这样会产生饥饿的问题。\n解决饥饿 type Mutex struct { state int32 sema uint32 } const ( mutexLocked = 1 \u0026lt;\u0026lt; iota // 1 mutexWoken // 2 mutexStarving // 4 mutexWaiterShift = iota // 3 starvationThresholdNs = 1e6 // 1ms ) func (m *Mutex) Lock() { if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { return } // Slow path m.lockSlow() } func (m *Mutex) lockSlow() { var waitStartTime int64 starving := false awoke := false iter := 0 old := m.state for { // 锁未释放，且不处于饥饿状态。 可以自xuan if old\u0026amp;(mutexLocked|mutexStarving) == mutexLocked \u0026amp;\u0026amp; runtime_canSpin(iter) { if runtime_canSpin(iter) { if !awoke \u0026amp;\u0026amp; old\u0026amp;mutexWoken == 0 \u0026amp;\u0026amp; old\u0026gt;\u0026gt;mutexWaiterShift != 0 \u0026amp;\u0026amp; atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken) { // 新的goroutine \u0026amp;\u0026amp; 没有唤醒的goroutine \u0026amp;\u0026amp; 有等待 \u0026amp;\u0026amp; 将当前giroutine设为唤醒状态 awoke = true } runtime_doSpin() iter++ old = m.state // 获取锁的状态，之后会检查锁是否释放 continue } new := old // 非饥饿模式，加锁 if old\u0026amp;mutexStarving == 0 { new |= mutexLocked } // 饥饿模式或者有锁 if old\u0026amp;(mutexLocked|mutexStarving) != 0 { new += 1\u0026lt;\u0026lt;mutexWaiterShift } // 有锁，设置饥饿模式 if starving \u0026amp;\u0026amp; old\u0026amp;mutexLocked != 0 { new |= mutexStarving } if awoke { if new\u0026amp;mutexWoken == 0 { throw(\u0026quot;sync: inconsistent mutex state\u0026quot;) } new \u0026amp;^ = mutexWoken } if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { // 无锁，非饥饿模式 if old\u0026amp;(mutexLocked|mutexStarving) == 0 { break } // 处理饥饿状态 // 如果以前就在队列里，加入到队列头 queueLifo := waitStartTime != 0 if waitStartTime == 0 { waitStartTime = runtime_nanotime() } // 阻塞等待 runtime_Semacquire(\u0026amp;m.sema, queueLifo, 1) starving = starving || runtime_nanotime()-waitStartTime \u0026gt; starvationThresholdNs old = m.state // 如果锁已经处于饥饿状态，直接抢到锁，返回 if old\u0026amp;mutexStarving != 0 { if old\u0026amp;(mutexLocked|mutexWoken) != 0 || old\u0026gt;\u0026gt;mutexWaiterShift == 0 { throw(\u0026quot;sync: inconsistent mutex state\u0026quot;) } // 加锁且将waiter减1 delta := int32(mutexLocked - 1\u0026lt;\u0026lt;mutexWaiterShift) if !starving || old\u0026gt;\u0026gt;mutexWaiterShift == 1 { delta -= mutexStarving // 最后一个waiter或者已经不饥饿，清除标记 } atmoc.AddInt32(\u0026amp;m.state, delta) break } awoke = true iter = 0 } } else { old = m.state } } }  ","id":2,"section":"posts","summary":"Mutex 架构演进方向 golang 中的 Mutex 是互斥锁，它的实现不是一成不变的，主要经历了以下的变化 初版：使用 flag 标记字段是否有锁 给新人机会：新的 goroutine 也有机会竞争锁 多给","tags":null,"title":"Golang Mutex 源码解析","uri":"https://fearlessfe.github.io/blog/2022/01/mutex/","year":"2022"}],"tags":[]}