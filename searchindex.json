{"categories":[],"posts":[{"content":"所有权系统 所有权是rust管理内存的一系列的规则。\nrust 的每个值都有一个被称为 \u0026lsquo;owner\u0026rsquo; 的变量 每个时刻只能有一个 owner 当 owner 出作用域后，值会被丢弃 String 类型 字符串字面量是不可变的，如果需要可变字符串，可以使用 String 类型，它的内存会分配在堆上\nfn main() { let mut s = String.from(\u0026quot;Hello\u0026quot;) s.push_str(\u0026quot;, world!\u0026quot;); } 变量与值的交互 下面的代码是简单的复制语句。首先我们需要了解 String 类型在栈上存的是一个简单的结构体 存储着字符串的长度，容量和指向实际内容的指针。\nfn main() { let x = 5; let y = x; let s1 = String.from(\u0026quot;hello\u0026quot;); let s2 = s1; } move 语义 上面代码中执行 s2 = s1 后，rust 只会复制栈上的内容，堆上的内容没有变化。 同时 s1 将失效，可以理解为数据的所有权从 s1 转移到了 s2。这就是 move 语义， 代表所有权的转移。\nclone 语义 如果需要 s1 和 s2 同时有效，需要使用 clone 方式，这会深度拷贝，不仅拷贝栈上的值， 也会拷贝堆上的值。代码如下\nfn main() { let s1 = String.from(\u0026quot;hello\u0026quot;); let s2 = s1.clone(); } copy 语义 最开始的代码中，执行 y = x 后，x 和 y 都是有效的。这是因为rust为栈上的数据类型默认 实现了 Copy 语义，直接复制栈上的数据。\n需要注意的是，这个只有栈上数据类型才有copy语义。一下数据类型都自动实现了copy语义\n整数和浮点数，如 u32，f64 布尔类型 字符类型 元组，其中的每个类型都实现了 Copy，(i32,u32)可以。(i32,String)不行 数组，和元组类似 所有权和函数 函数传参和变量赋值类似，要么是 move，要么是 copy。\nfn main() { let s = String::from(\u0026quot;hello\u0026quot;); // s comes into scope takes_ownership(s); // s's value moves into the function... // ... and so is no longer valid here let x = 5; // x comes into scope makes_copy(x); // x would move into the function, // but i32 is Copy, so it's okay to still // use x afterward } // Here, x goes out of scope, then s. But because s's value was moved, nothing // special happens. fn takes_ownership(some_string: String) { // some_string comes into scope println!(\u0026quot;{}\u0026quot;, some_string); } // Here, some_string goes out of scope and `drop` is called. The backing // memory is freed. fn makes_copy(some_integer: i32) { // some_integer comes into scope println!(\u0026quot;{}\u0026quot;, some_integer); } // Here, some_integer goes out of scope. Nothing special happens. 函数返回值 函数返回值也会有所有权的转移\nfn main() { let s1 = gives_ownership(); // gives_ownership moves its return // value into s1 let s2 = String::from(\u0026quot;hello\u0026quot;); // s2 comes into scope let s3 = takes_and_gives_back(s2); // s2 is moved into // takes_and_gives_back, which also // moves its return value into s3 } // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing // happens. s1 goes out of scope and is dropped. fn gives_ownership() -\u0026gt; String { // gives_ownership will move its // return value into the function // that calls it let some_string = String::from(\u0026quot;yours\u0026quot;); // some_string comes into scope some_string // some_string is returned and // moves out to the calling // function } // This function takes a String and returns one fn takes_and_gives_back(a_string: String) -\u0026gt; String { // a_string comes into // scope a_string // a_string is returned and moves out to the calling function } 引用和借用 如果我们只想将值传递给函数，但是不影响所有权，我们需要用到引用。\n引用就像一个指针，它指向的地址就是实际的内容；但和指针不同的是，引用可以保证指向的有效的值。\nfn main() { let s1 = String.from(\u0026quot;Hello\u0026quot;); let len = calculate_length(\u0026amp;s1); println!(\u0026quot;The length of '{}' is {}.\u0026quot;, s1, len); } // 参数 s 为一个指针，指针指向的是变量 s1 fn calculate_length(s: \u0026amp;String) -\u0026gt; usize { s.len() } // \u0026amp; 表明是一个引用，没有所有权。所以函数结束后，所有权没有变化 我们将创建引用的行为称为借用。引用默认也是不可变的，如果在函数中修改引用就会报错。\n如果需要修改引用，应创建可变引用。\nfn main() { let mut s = String.from(\u0026quot;hello\u0026quot;); change(\u0026amp;mut s); } fn change(s: \u0026amp;mut String) { some_string.push_str(\u0026quot;, world\u0026quot;); } 需要注意的是，在某一时刻只能有一个可变引用。\n同一代码块中，需要注意 不可变引用和可变引用的生命周期。一下代码是正常的\nfn main() { let mut s = String::from(\u0026quot;hello\u0026quot;); let r1 = \u0026amp;s; // no problem let r2 = \u0026amp;s; // no problem println!(\u0026quot;{} and {}\u0026quot;, r1, r2); // variables r1 and r2 will not be used after this point let r3 = \u0026amp;mut s; // no problem println!(\u0026quot;{}\u0026quot;, r3); } 引用的准则\n任意时刻，你可有一个可变引用或任意多的不可变引用。 引用一定是有效的 切片类型 切片让你引用一块连续的区间，而不是所有的集合。切片是引用，所以没有所有权。\n现在有一个需求，需要找到字符串中的第一个单词。我们需要考虑该函数返回什么？可以考虑返回 第一个单词的位置。\nfn main() { let mut s = String::from(\u0026quot;hello world\u0026quot;); let word = first_word(\u0026amp;s); // word will get the value 5 s.clear(); // this empties the String, making it equal to \u0026quot;\u0026quot; // word still has the value 5 here, but there's no more string that } fn first_world(s: \u0026amp;String) -\u0026gt; usize { let bytes = s.as_bytes(); for (i, \u0026amp;item) in bytes.iter().enumerate() { if item = b' ' { return i; } } s.len() } 上述代码的问题就是返回的位置是没有意义的，即使字符串清空了，位置还是存在。 所以可以考虑切片。\nfn main() { let s = String::from(\u0026quot;hello\u0026quot;); let slice = \u0026amp;s[0..2]; // index [0, 2)，不包含索引2 let slice = \u0026amp;s[..2]; } 切片的位置必须是有效的 UTF-8 的分界，否则会出错。\nstring slice 的类型是 \u0026amp;str\nfn first_word(s: \u0026amp;String) -\u0026gt; \u0026amp;str { let bytes = s.as_bytes(); for (i, \u0026amp;item) in bytes.iter().enumerate() { if item == b' ' { return \u0026amp;s[0..i]; } } \u0026amp;s[..] } 前面说到字符串字面量直接存储在二进制文件中，所以字符串字面量就是字符串切片类型，\u0026amp;str. 除了字符串有切片，数组也有切片\nlet a = [1,2,3,4,5]; let slice = \u0026amp;a[1..3]; assert_eq!(slice, \u0026amp;[2, 3]); ","id":0,"section":"posts","summary":"所有权系统 所有权是rust管理内存的一系列的规则。 rust 的每个值都有一个被称为 \u0026lsquo;owner\u0026rsquo; 的变量 每个时刻只能有一个 owner 当 owner 出作用域后，值会被丢弃 String 类型 字符串","tags":null,"title":"Rust Ownership","uri":"https://fearlessfe.github.io/blog/2022/06/rust-ownership/","year":"2022"},{"content":"通用概念 变量和可变性 变量 rust 中变量默认是不可变的。下面的代码片段会报错，因为 x 是不可变的，不能重新赋值。 如果需要声明可变变量，需要加上关键字 mut\nfn main() { let x = 5; // let mut x = 5; println!(\u0026quot;x is: {}\u0026quot;, x ) x = 6; println!(\u0026quot;x is: {}\u0026quot;, x ) } 常量 rust 中用 const 来声明常量，常量是不可变的。 常量的值在编译阶段就需要确定，因此不能是运行阶段计算出来的值。\n常量的值在整个程序运行期间都是有效的。\n变量遮蔽 用 let 声明相同的变量，会屏蔽前面的同名变量。 下面的代码用num类型的变量遮蔽了前面的字符串类型变量。\nfn main() { let x = \u0026quot; \u0026quot;; let x = x.len(); println!(\u0026quot;x is: {}\u0026quot;, x ) } 数据类型 rust 中每个值都有一个确定的类型。接下来我们将了解一下两种数据类型子集：标量和复合变量。\n标量类型 标量类型代表一个单一的值。rust 有四种标量类型： 整数，浮点数，布尔和字符。\n整数类型：i是有符号，u是无符号。长度 8-16-32-64-128. isize 和 usize 类型和系统有关 32 位系统代表 i32或u32，64位系统代表 i64或u64.\nfn main() { let a: i32 = 98_222; let b: i32 = 0xff; let c: i32 = 0x77; let d: i32 = 0b1111_0000; let e: u8 = b'A'; // 代表 Byte，与u8一致 } 复合类型 将多个值组合成一个类型。rust原生类型有元组和数组。\n元组类型 元组将多个不同类型的值组合起来，元组的长度是固定的。\nfn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); // 通过解构赋值 let (x,y,z) = tup; // 通过下标 let a = tup.0; let b = tup.1; } 数组类型 数组中只能有一个类型，而且长度也是固定的。越界访问会报错。\nfn main() { let a: [i32; 5] = [1, 2, 3, 4, 5]; // 通过下标 let first = a[0]; let second = a[1]; } 函数 rust 用 fn 声明函数， main 函数是程序的入口。函数命名风格为 snake_case。\n函数参数必须要明确类型\nfn main() { println!(\u0026quot;Hello, world!\u0026quot;); another_function(5, 'h'); } fn another_function(x: i32, unit_label: char) { println!(\u0026quot;Another function.\u0026quot;); } 语句和表达式 语句没有返回值，表达式有返回值。\nfn main() { let y = 6; // 声明语句 // 大括号中是一个表达式，最后一个没有逗号，代表返回值 // y 的值是4 let y = { let x = 3; x + 1 }; } 带返回值的函数 fn five() -\u0026gt; i32 { 5 } fn main() { let x = five(); println!(\u0026quot;The value of x is: {}\u0026quot;, x); } 控制流 if 表达式 if 是表达式，也会有返回值。\nfn main() { let number = 3; if number \u0026lt; 5 { println!(\u0026quot;condition was true\u0026quot;); } else { println!(\u0026quot;condition was false\u0026quot;); } let condition = true; let number = if condition { 5 } else { 6 }; } loop 循环 break 跳出当前循环。 loop 也是表达式，也有可以有返回值。\nfn main() { let mut count = 0; 'counting_up: loop { println!(\u0026quot;count = {}\u0026quot;, count); let mut remaining = 10; loop { println!(\u0026quot;remaining = {}\u0026quot;, remaining); if remaining == 9 { break; } if count == 2 { break 'counting_up; } remaining -= 1; } count += 1; } println!(\u0026quot;End count = {}\u0026quot;, count); } while 循环\nfn main() { let a = [10, 20, 30, 40, 50]; let mut index = 0; while index \u0026lt; 5 { println!(\u0026quot;the value is: {}\u0026quot;, a[index]); index += 1; } } for..in循环数组\nfn main() { let a = [10, 20, 30, 40, 50]; for element in a { println!(\u0026quot;the value is: {}\u0026quot;, element); } for number in (1..4).rev() { println!(\u0026quot;{}!\u0026quot;, number); } println!(\u0026quot;LIFTOFF!!!\u0026quot;); } ","id":1,"section":"posts","summary":"通用概念 变量和可变性 变量 rust 中变量默认是不可变的。下面的代码片段会报错，因为 x 是不可变的，不能重新赋值。 如果需要声明可变变量，需要加上关键字 mut","tags":null,"title":"Rust Basic","uri":"https://fearlessfe.github.io/blog/2022/06/rust-basic/","year":"2022"},{"content":"类组件与函数组件 函数组件能更好的复用逻辑\n高阶组件缺点：组件静态方法，ref 传递\nOOP思想与函数式思想，组合优于继承\nsetState 是否为异步 在 React 生命周期和合成事件中，是批量更新，表现为异步。在 addEventListener, setTimeout, setInterval 中，不受 React 控制，是同步的\n为什么设置为异步更新？保持内部一致性，props 无法同步；为后面的 React 异步设计打下基础。\nReact 跨层级通信 确定主题，列举场景\n父子: props 子父: 回调函数 兄弟: 公共父组件 无关系: Context，状态管理工具 状态管理 FLUX 单项数据流\nRedux 如何处理副作用：Dispatch 中间件处理副作用 或者 在 Reducer 中处理副作用\n分形架构：如果子组件能够以同样的结果，作为一个应用使用\nRedux：单一数据源，reducer纯函数， store 只读\nMobx：监听方式，Mobx5 前，采用 Object.defineProperty, 5 之后采用 Proxy 方案\nVirtual DOM 工作原理 XHP 防止 XSS，但是状态更新需要重新渲染全部页面，影响用户体验。\nReact.createElement 返回的是一个 js 的对象。\ndiff 函数，计算状态变更前后虚拟 DOM 树的差异 渲染函数，渲染整个虚拟 DOM 树或者处理差异点 所以 React 和 ReactDOM 是两个库\nVirtual DOM 的优势\n大量直接操作 DOM 容易引起网页性能下降，这样的情况下，React 基于虚拟DOM的diff处理与皮处理操作可降低 DOM 的操作范围和频次，提升页面性能\n防止 XSS\n跨平台成本低\nVirtual DOM 的劣势\n内存，高性能场景难以优化\nReact Diff 算法与其他框架的不同 更新时机：setState, forceUpdate, hooks调用等 遍历算法：深度优先遍历，保证组件生命周期的一致性 优化策略：树的遍历，复杂度为O(n^3)。React 使用分治的思想，将复杂度将为O(n) 从 树，组件，元素三个方向来优化\n忽略节点跨层级操作场景，对树进行分层比较，两棵树只对同一层次节点进行比较 组件的 Class 是同一类型，则进行树比对 同一层级的节点，通过 key 的方式直接移动 Fiber 机制下节点与树分别采用 FiberNode 和 FiberTree 进行重构\ncurrent 树与 workInProgress 两株树双缓冲，直接更新 current 树的指针\nVue2.0 使用 snabbdom,整体思路与 React 相同。\nReact 渲染流程 核心 阶段 调度 事务 协调，Reconciler\nStack Reconciler 是 React 15 及以前版本的渲染方案，核心是以递归的方式逐级调度栈中子节点到父节点的渲染\nFiber Reconciler 是 React 16 及以后版本的渲染方案，核心设计是增量渲染，将渲染工作分隔为多区块，将其分散到多个帧中执行\nReact 渲染的整体策略是递归，并通过事务建立 React 与虚拟 DOM 的联系并完成调度\n渲染过程大概一致，但协调不同\nReact 渲染异常 是什么？怎么解决？\n预防： ?. 操作符 兜底： 高阶组件，hooks\n如何分析和调优性能瓶颈 性能指标，统计数据\n避免重复渲染 React Hooks 使用限制 问题 组件难以复用状态逻辑 类难以编译优化 类组件逻辑杂乱\n限制 不要嵌套调用hook 只能在函数式组件中调用hook\nuseEffect 与 useLayoutEffect 共同点\n都是用于处理副作用，如DOM事件\n不同点\n直接操作 DOM 样式，或者引起页面闪烁，使用 useLayoutEffect\nuseLayoutEffect：会在所有 DOM 变更之后同步调用，所以可以读取 DOM 布局并同步触发重渲染，但计算量较大时，会造成卡顿\nReact-Router 实现原理及工作方式 实现原理\nhash 路由 history\nReact 工具库 初始化： create-react-app, umi 路由： react-router css: css in js: styled-component, classnames 基础组件： antd 状态管理：redux， mobx 构建： webpack， rollup， esbuild 检查： ESLint， prettier 测试： jest, react-testing-library, react-hooks-testing-library\n","id":2,"section":"posts","summary":"类组件与函数组件 函数组件能更好的复用逻辑 高阶组件缺点：组件静态方法，ref 传递 OOP思想与函数式思想，组合优于继承 setState 是否为异步 在 React 生命周期和","tags":null,"title":"React 笔记","uri":"https://fearlessfe.github.io/blog/2022/05/react/","year":"2022"},{"content":"最近面试 golang 被问到，golang 里面的 mutex 是什么类型的锁。很无奈，没了解过相关知识，没有答出来。\n在 google 上一搜，对 Java 中锁介绍的资料最多，从不同的角度出发，锁的分类也不同。下图引用了美图技术博客的分类\n下面对其中的几类锁做一下简单的介绍，然后看看 mutex 是什么类型的锁。\n乐观锁，悲观锁 乐观锁和悲观锁是以是否锁住同步资源来区分的。\n很显然，mutex 是悲观锁，goroutine 获取锁后，相关的资源也会锁住，不让其余 goroutine 操作。\n那么乐观锁是怎么处理多个 goroutine 的竞争关系呢？答案就是 CAS（Campare And Swap），先比较，再交换。 go里面的 atomic 包提供了相关方法,以 CompareAndSwapInt32 为例，该方法接受3个参数：\n内存地址,addr 需要比较的值,old 新的值,new 将 addr 处的值于 old 比较，如果相同，则将 addr 的值设置为 new，否则就返回 false。\natomic.CompareAndSwapInt32(\u0026amp;addr, old, new) CAS 的性能会远高于锁，但是 CAS 也会有一些不适用的情况。\nABA 问题：CAS 只是比较值是否改变，如果该地址初始值为 A，别的 goroutine 将值改为 B，后来🈶️有 goroutine 将值改为 A。CAS 是不能判断这种变化的，可能会产生一些问题。 只能对一个变量进行操作，无法保证多个变量的原子性。 除了 CAS，使用版本号也可以实现乐观锁。\n版本号的原理是在数据中加一个 version 字段，每次字段改变后， version 加 1。每次更新时，先比较当前版本于数据目前的版本是否一致，否则就不能更新数据。\n公平锁，非公平锁 按照多个 goroutine 竞争锁的时候，是否按照 FIFO 的顺序来获得锁，可以分为公平锁和非公平锁。\nmutex 的实现经历了多个版本，早期版本时按照 FIFO 的方式来实现的，是公平锁。但后来的版本为了性能，该为了非公平锁。详细资料可参考相关文章。\n目前 mutex 的实现是新的 goroutine 进来会先插队，插队失败后会排队。所以 mutex 是非公平锁。\n其余类型 mutex 是互斥锁，只能由单个 gouroutine 获取，而且不能重复的去获取同一把锁。所以 mutex 是不可重入锁，排它锁。\n总结 mutex 可以是 悲观锁，非公平锁，不可重入锁和排它锁。\n参考资料 【BAT面试题系列】面试官：你了解乐观锁和悲观锁吗？\n不可不说的Java“锁”事\n","id":3,"section":"posts","summary":"最近面试 golang 被问到，golang 里面的 mutex 是什么类型的锁。很无奈，没了解过相关知识，没有答出来。 在 google 上一搜，对 Java 中锁介绍的资料最多，从不同的角度","tags":null,"title":"golang 里面的 mutex 是什么类型的锁？","uri":"https://fearlessfe.github.io/blog/2022/02/%E6%82%B2%E8%A7%82%E9%94%81%E4%B9%90%E8%A7%82%E9%94%81/","year":"2022"},{"content":"为什么要写这篇文章 有一段时间 nodejs 工作经历，面试总是被问到 Event Loop,虽然看过官网上的文章，奈何总是记不住，面试也答不上来。因此，写这篇文章来加深印象。原文请👇这里\n什么是 Event Loop 虽然 Javascript 是单线程的，但是 Event Loop 让 Nodejs 能够执行非阻塞的 I/O。\n现代内核都是多线程的，它们可在后台执行多个操作。但其中一个操作完成后，内核通知 Nodejs 以便将相应的回调添加到轮询队列，最后回调会被执行。\nEvent Loop简介 当 Nodejs 运行时，它会初始化事件循环，执行输入的脚本，脚本中可能会调用异步的 API，timer 函数或 process.nextTick(),然后开始事件循环。\n下图（来源于原文）简单的描述了事件循环操作顺序。\n┌───────────────────────────┐ ┌─\u0026gt;│ timers │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ pending callbacks │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ idle, prepare │ │ └─────────────┬─────────────┘ ┌───────────────┐ │ ┌─────────────┴─────────────┐ │ incoming: │ │ │ poll │\u0026lt;─────┤ connections, │ │ └─────────────┬─────────────┘ │ data, etc. │ │ ┌─────────────┴─────────────┐ └───────────────┘ │ │ check │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ └──┤ close callbacks │ └───────────────────────────┘\n图中每个盒子代表事件循环中一个阶段\n每个阶段都是一个队列，按照 FIFO 的方式执行回调函数。事件循环进入其中一个阶段后，首先会执行该阶段特定的操作。然后执行该阶段队列中的回调，知道队列中回调全部执行完或者达到最大的回调限制，然后事件循环进入下一个阶段。\n由于这些操作可能会产生新的事件，而轮询阶段（poll phase）新的事件由内核加入到队列，因此处理轮询事件时也会有新的事件加入到队列中。因此，长时间运行的回调会让轮询阶段的时间远超过计时器的阈值。\n阶段概览 timers: 这个阶段执行 setTimeout() 和 setInterval() 的回调 pending callbacks：执行推迟到下一个循环的 I/O 回调 idle,prepare: 仅供内部使用 poll（轮询）: 检索新的 I/O 事件；执行 I/O 相关的回调（几乎所有的回调，除了关闭回调，定时器调度的回调和setImmediate()）,节点会在适当的时候阻塞。 check：setImmediate()的回调在这里执行。 close callbacks: 关闭的回调，比如socket.on('close',...) 在事件循环之间，Nodejs 会检查它是否正在等待异步 I/O 或计时器。如果没有，则退出。（这里退出应该是指退出 nodejs 程序）。\n阶段详情 timers 计时器可以指定一个阈值，到达阈值后执行回调，而不是决定回调执行的确切时间。计时器的回调会在指定的时间过后尽可能早的执行，但是回调的执行可能会延迟。\n轮询阶段控制计时器回调的执行\n举个例子，定时器在100ms后执行回调，然后一个异步读取文件会花 95ms\nconst fs = require('fs'); function someAsyncOperation(callback) { fs.readFile('/path/to/file', callback) } const timeoutScheduled = Date.now(); setTimeout(() =\u0026gt; { const delay = Date.now() - timeoutScheduled console.log(`${delay}ms have passed since I was scheduled`) }, 100) // someAsyncOperation takes 95ms someAsyncOperation(() =\u0026gt; { const startCallback = Date.now() // do something will take 10ms while(Date.now() - startCallback \u0026lt; 10) { // do nothing } }) 当事件循环进入轮询阶段，此时队列是空的，所以会等待一直达到最近的计时器阈值。 95ms 后，读取文件的操作完成，回调进入轮询阶段的队列，然后花 10ms 执行回调。执行完成后，队列为空，这时候到达了 100ms 的阈值，因此会回到 timer 阶段执行定时器的回调。所以定时器的回调会在 105ms 后被执行，而不是 100ms。\n为了防止轮询阶段过长使得事件循环陷入饥饿，libuv 对轮询阶段设置处理事件的最大值\npending callbacks 这个阶段执行系统操作的回调，比如 TCP error。比如一个 TCP 连接收到了 ECONNREFUSED,一些 *nix 的系统想要 report 这个错误。这些事件的回调会在这个阶段执行。\nidle prepare 这个阶段仅供内部使用\npoll(轮询) 轮询阶段主要有两个功能：\n计算应该阻塞和轮询 I/O 的时间 处理轮询队列的事件 当事件循环进入 轮询阶段并且没有定时器，将发生以下两件事之一：\n如果轮询队列不是空的，那事件循环会按顺序同步的执行队列中的事件，知道队列为空或者达到最大的事件限制 如果队列为空，则可能发生下列两件事之一： 如果有 setImmediate() 事件，事件循环会结束轮询阶段，进入 check 阶段，执行该阶段的回调。 如果没有 setImmediate() 事件，事件循环会等待回调被加入到队列，然后立即执行回调 如果轮询队列为空，事件循环会检查是否达到定时器的阈值。如果有，事件循环会回到 timer 阶段，执行定时器的回调。\ncheck 这个阶段是在轮询阶段结束后执行该阶段的回调。\nsetImmediate()是一个特别的定时器，在单独的阶段执行。\n一般来说，代码执行后，事件循环会最终达到轮询阶段，等待新来的链接，请求等。如果有 setImmediate() 而且轮询阶段处于空闲状态，轮询阶段会结束，然后进入 check 阶段执行 setImmediate() 的回调。\nclose callback 如果套接字或句柄被突然关闭（例如 socket.destroy()）,此阶段会 emit \u0026lsquo;close\u0026rsquo; 事件。否则会通过 process.nextTick()\nsetImmediate() VS setTimeout() setImmediate() 和 setTimeout() 比较类似，但是根据调用时间不同而有不同的表现。\nsetImmediate() 设计为 轮询阶段结束后调用 setTimeout() 达到设定的阈值后调用 如果两者都在主模块中调用，那么两者的顺序是不固定的，两者顺序取决于处理器的性能。\nsetTimeout(() =\u0026gt; { console.log('timeout) }, 0) setImmediate(() =\u0026gt; { console.log('immediate) }, 0) 如果在 I/O 事件中调用，则 setImmediate 总是先执行\nconst fs = require('fs'); fs.readFile(\u0026quot;\u0026quot;, () =\u0026gt; { setTimeout(() =\u0026gt; { console.log('timeout) }, 0) setImmediate(() =\u0026gt; { console.log('immediate) }, 0) }) process.nextTick() 理解 nextTick process.nextTick() 没有在图中展示，即使这是一个异步的 API。因为 nextTick 不属于事件循环。\n在某个阶段的任意时刻调用 process.nextTick()，它的回调会在事件循环继续之前执行。这会出现一些坏的情况，比如在 process.nextTick() 递归调用 process.nextTick()，这会使得事件循环无法继续。\n为什么需要 nextTick nextTick 一部分的设计理念是 API 应该始终是异步的，即使它不是。以下面的代码为例\nfunction apiCall(arg, callback) { if (typeof arg != 'string') { return process.nextTick(callback, new TypeError('args should be string')) } } 这样回调会在所有用户的 code 执行完毕后，在进入事件循环之前才执行。\n下面是一个真正的例子\nconst server = net.createServer(() =\u0026gt; {}).listen(8080) server.on('listening', () =\u0026gt; {}) 只有绑定端口后， \u0026rsquo;listening\u0026rsquo; 回调才会执行。但问题是那时候 \u0026rsquo;listening\u0026rsquo; 回调还没设置。 所以 \u0026rsquo;listening\u0026rsquo; 回调放在 nextTick() 中。\nprocess.nextTick() VS setImmediate() 这两者比较类似，但是名字有点让人困惑\nprocess.nextTick() 在当前阶段执行 setImmediate() 在时间循环中执行 建议开发者在所有情况下都使用 setImmediate()\n为什么需要 process.nextTick() 主要有以下两个原因\n允许用户处理错误，清理不需要的资源或在事件循环之前再次尝试请求 有时，需要允许回调在调用栈解除后但在事件循环之前调用 一个符合用户期望的例子如下\nconst server = net.createServer(); server.on('connection', (conn) =\u0026gt; {}) server.listen(8000) server.on('listening', () =\u0026gt; {}) listen() 在时间循环开始时允许，如果 \u0026rsquo;listening\u0026rsquo; 函数放在 setImmediate 中，那么有一定概率在轮询阶段收到新的请求的时候，\u0026rsquo;listening\u0026rsquo; 回调还没有注册。\n另一个例子是在构造函数中 emit 事件\nconst EventEmitter = require('events') const util = require('util') function MyEmitter() { EventEmitter.call(this) this.emit('event) } util.inherits(MyEmitter, EventEmitter) const myEmitter = new MyEmitter(); myEmitter.on('event', () =\u0026gt; { console.log('event occurred!') }) 上诉代码中的事件不会触发，因为脚本不会处理到为事件分配回调的地方。如果将 this.emit(\u0026rsquo;event) 放入 process.nextTick() 中执行，则会触发 \u0026rsquo;event\u0026rsquo; 事件。\n","id":4,"section":"posts","summary":"为什么要写这篇文章 有一段时间 nodejs 工作经历，面试总是被问到 Event Loop,虽然看过官网上的文章，奈何总是记不住，面试也答不上来。因此，写这篇文章来加","tags":null,"title":"The Node.js Event Loop, Timers and process.nextTick()","uri":"https://fearlessfe.github.io/blog/2022/02/event-loop/","year":"2022"},{"content":"Mutex 架构演进方向 golang 中的 Mutex 是互斥锁，它的实现不是一成不变的，主要经历了以下的变化\n初版：使用 flag 标记字段是否有锁 给新人机会：新的 goroutine 也有机会竞争锁 多给些机会：新来的和被唤醒的有更多机会竞争 解决饥饿：解决竞争问题，不让 goroutine 一直等待 初版互斥锁 初版互斥锁使用 CAS 指令实现，以下代码为 Mutex 的初版实现。\nCAS 指令将给定的值和一个内存地址中的值进行比较，如果是同一个值，就用新的值替换内存中的值。\n// CAS操作 func cas(val *int32, old, new int32) bool func semacquire(*int32) func semrelease(*int32) // 互斥锁结构 type Mutex struct { key int32 // 锁是否被持有的flag sema int32 // 信号量，用来阻塞/唤醒goroutine } func xadd(val *int32, delta int32) (new int32) { for { v := val if cas(val, v, v + delta) { return v + delta } } panic(\u0026quot;unreached\u0026quot;) } func (m *Mutex) Lock() { if xadd(\u0026amp;m.key, 1) == 1 { return } semacquire(\u0026amp;m.sema) // 进入队列 } func (m *Mutex) Unlock() { if xadd(\u0026amp;m.key, -1) == 0 { return } semrelease(\u0026amp;m.sema) // 唤醒队列中的goroutine } 初版实现通过 Mutex 的 key 属性作为标识，key 为0或1来表示锁是否被占用。\nUnlock 方法可以被任意的 goroutine 调用，即使是没有持有这个锁的 goroutine。所以使用 Mutex 时，一定要遵循“谁申请，谁释放”的原则。\n这种实现方式，按照 FIFO 的方式来获取锁。但是在高并发的情况下，会频繁的切换上下文，性能会有损耗。如果能够将锁交给正在占用 CPU 时间片的 goroutine 的话，会有更好的性能。\n给新人机会 这一版尝试给新来的 goroutine 获取锁的机会。\ntype Mutex struct { state int32 sema uint32 } // 32位 state 是复合字段。最小的一位表示锁是否占有，第二位表示是否有唤醒的 goroutine，剩下的代表等待该锁的 goroutine 数量 const ( mutexLocked = 1 \u0026lt;\u0026lt; iota // 1 mutexWoken // 2 mutexWaiterShift = iota // 2 ) func (m *Mutex) Lock() { // state 为 0,直接获取锁 if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { return } awoke := false for { old := m.state new := old | mutexLocked // 设置加锁的状态 // old 为有锁的状态，等待者加1 if old \u0026amp; mutexLocked != 0 { new = old + 1 \u0026lt;\u0026lt; mutexWaiterShift } if awoke { // goroutine 是被唤醒 // 将 mutexWoken 标志位变为0 new = new \u0026amp;^ mutexWoken } if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { // 无锁状态，直接获取锁 if old \u0026amp; mutexLocked == 0 { break } runtime.Semacquire(\u0026amp;m.sema) // 休眠 awoke = true // 唤醒后，awoke设置为true } } } 请求锁的 goroutine 分为新来的和被唤醒的，两者都会尝试获取锁。两者的区别见下表\n请求锁 锁被持有 锁未被持有 新来的goroutine waiter++ 休眠 获取锁 被唤醒的goroutine 清除mutexWoken，加入等待队列 清除mutexWoken，获取锁 func (m *Mutex) Unlock() { new := atomic.AddInt32(\u0026amp;m.state, -mutexLocked) // 去掉锁标志 if (new + mutexLocked) \u0026amp; mutexLocked == 0 { // unlock of unclocked mutex panic(\u0026quot;....\u0026quot;) } old := new for { // 没有等待者 或 (唤醒状态的goroutine或有锁) if old\u0026gt;\u0026gt;mutexWaiterShift == 0 || old\u0026amp;(mutexLocked|mutexWoken) != 0 { return } // 等待者减1，唤醒标志位设为1 new = (old - 1\u0026lt;\u0026lt;mutexWaiterShift) | mutexWoken if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { runtime.Semrelease(\u0026amp;m.sema) return } old = m.state } } 释放锁时，首先会将去掉锁的标志位。如果已经是释放的状态，则直接panic。 进入 for 循环后， 如果没有等待者，return 如果现在有唤醒的 goroutine 或者持有锁的 goroutine，直接交给其余的 goroutine 处理，return\n将等待者减1，设置唤醒标志位，然后唤醒等待的 goroutine.\n这一版本的实现，让新来的 goroutine 和唤醒的 goroutine 竞争，使得新来的 goroutine 可以获取锁，这样可以减少上下文的切换，提升性能。\n多给些机会 新来的 goroutine 和唤醒的 goroutine 如果没有获取到锁，会通过自旋的方式，尝试检查锁是否被释放。经过一定次数的尝试后，再执行原来的操作。改动后的 Lock 实现如下\nfunc (m *Mutex) Lock() { // state 为 0,直接获取锁 if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { return } awoke := false iter := 0 for { old := m.state new := old | mutexLocked if old \u0026amp; mutexLocked != 0 { if runtime_canSpin(iter) { // 新的goroutine \u0026amp;\u0026amp; 没有唤醒的goroutine \u0026amp;\u0026amp; 有等待者 \u0026amp;\u0026amp; 设置mutexWoken标志位 if !awoke \u0026amp;\u0026amp; old\u0026amp;mutexWoken == 0 \u0026amp;\u0026amp; old\u0026gt;\u0026gt;mutexWaiterShift != 0 \u0026amp;\u0026amp; atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken) { awoke = true // 设置 mutexWoken 标志位后，Unlock 方法不会唤醒新的 goroutine，自选期间获取锁的概率变大 } runtime_doSpin() iter++ continue } // 自旋结束，等待列表加1 new = old + 1\u0026lt;\u0026lt;mutexWaiterShift } if awoke { if new\u0026amp;mutexWoken == 0 { panic(\u0026quot;sync: inconsistent mutex state\u0026quot;) } new \u0026amp;^ = mutexWoken // 新状态清除唤醒标记 } if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { if old\u0026amp;mutexLocked == 0 { break } runtime_Semacquire(\u0026amp;m.sema) awoke = true iter = 0 } } } 上面自旋时，会设置唤醒标志位，导致等待队列的goroutine可能一直处于休眠状态，这样会产生饥饿的问题。\n解决饥饿 type Mutex struct { state int32 sema uint32 } const ( mutexLocked = 1 \u0026lt;\u0026lt; iota // 1 mutexWoken // 2 mutexStarving // 4 mutexWaiterShift = iota // 3 starvationThresholdNs = 1e6 // 1ms ) func (m *Mutex) Lock() { if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { return } // Slow path m.lockSlow() } func (m *Mutex) lockSlow() { var waitStartTime int64 starving := false awoke := false iter := 0 old := m.state for { // 锁未释放，且不处于饥饿状态。 可以自xuan if old\u0026amp;(mutexLocked|mutexStarving) == mutexLocked \u0026amp;\u0026amp; runtime_canSpin(iter) { if runtime_canSpin(iter) { if !awoke \u0026amp;\u0026amp; old\u0026amp;mutexWoken == 0 \u0026amp;\u0026amp; old\u0026gt;\u0026gt;mutexWaiterShift != 0 \u0026amp;\u0026amp; atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken) { // 新的goroutine \u0026amp;\u0026amp; 没有唤醒的goroutine \u0026amp;\u0026amp; 有等待 \u0026amp;\u0026amp; 将当前giroutine设为唤醒状态 awoke = true } runtime_doSpin() iter++ old = m.state // 获取锁的状态，之后会检查锁是否释放 continue } new := old // 非饥饿模式，加锁 if old\u0026amp;mutexStarving == 0 { new |= mutexLocked } // 饥饿模式或者有锁 if old\u0026amp;(mutexLocked|mutexStarving) != 0 { new += 1\u0026lt;\u0026lt;mutexWaiterShift } // 有锁，设置饥饿模式 if starving \u0026amp;\u0026amp; old\u0026amp;mutexLocked != 0 { new |= mutexStarving } if awoke { if new\u0026amp;mutexWoken == 0 { throw(\u0026quot;sync: inconsistent mutex state\u0026quot;) } new \u0026amp;^ = mutexWoken } if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { // 无锁，非饥饿模式 if old\u0026amp;(mutexLocked|mutexStarving) == 0 { break } // 处理饥饿状态 // 如果以前就在队列里，加入到队列头 queueLifo := waitStartTime != 0 if waitStartTime == 0 { waitStartTime = runtime_nanotime() } // 阻塞等待 runtime_Semacquire(\u0026amp;m.sema, queueLifo, 1) starving = starving || runtime_nanotime()-waitStartTime \u0026gt; starvationThresholdNs old = m.state // 如果锁已经处于饥饿状态，直接抢到锁，返回 if old\u0026amp;mutexStarving != 0 { if old\u0026amp;(mutexLocked|mutexWoken) != 0 || old\u0026gt;\u0026gt;mutexWaiterShift == 0 { throw(\u0026quot;sync: inconsistent mutex state\u0026quot;) } // 加锁且将waiter减1 delta := int32(mutexLocked - 1\u0026lt;\u0026lt;mutexWaiterShift) if !starving || old\u0026gt;\u0026gt;mutexWaiterShift == 1 { delta -= mutexStarving // 最后一个waiter或者已经不饥饿，清除标记 } atmoc.AddInt32(\u0026amp;m.state, delta) break } awoke = true iter = 0 } } else { old = m.state } } } ","id":5,"section":"posts","summary":"Mutex 架构演进方向 golang 中的 Mutex 是互斥锁，它的实现不是一成不变的，主要经历了以下的变化 初版：使用 flag 标记字段是否有锁 给新人机会：新的 goroutine 也有机会竞争锁 多给","tags":null,"title":"Golang Mutex 源码解析","uri":"https://fearlessfe.github.io/blog/2022/01/mutex/","year":"2022"}],"tags":[]}