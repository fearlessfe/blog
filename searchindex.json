{"categories":[],"posts":[{"content":"锁类型 mysql 中的锁大致分为 全局锁，表级锁和行锁 三类\n全局锁 全局锁就是对整个数据库实例加锁，命令如下\nFlush tables with read lock (FTWRL)\n全局锁的典型使用场景就是做全库逻辑备份\n表级锁 mysql 表级锁也分为 表锁和元数据锁\n表锁的语句如下\nlock tables \u0026hellip;read/write eg: lock tables t1 read, t2 write\n执行上面的语句后，所有线程均不可 读t1，写t2\n元数据锁主要是对表结构锁定，防止更新数据的过程中更改表的结构。 元数据锁不用显示声明，访问一个表的时候会自动加索\n行锁 MySQL的行锁是由各个引擎实现的\n行锁，innodb 只有通过检索索引才会有行锁\n不同事务中，对相同的行的更新会引起锁的争抢，甚至会引起死锁。\n","id":0,"section":"posts","summary":"锁类型 mysql 中的锁大致分为 全局锁，表级锁和行锁 三类 全局锁 全局锁就是对整个数据库实例加锁，命令如下 Flush tables with read lock (FTWRL) 全局锁的典型使用场景就是做全库逻辑备","tags":null,"title":"Mysql Lock","uri":"https://fearlessfe.github.io/blog/2022/07/mysql-lock/","year":"2022"},{"content":"innodb 索引 在 innodb 引擎中，每个索引就是一颗 B+ 树。索引分为主键索引和非主键索引\n主键索引：也叫 聚簇索引，叶子结点存放的就是整行数据 非主键索引：也叫 二级索引，叶子结点存放的是主键的值 通过非主键索引搜索数据，得到主键的值，然后在主键索引搜索，会多一次索引数的遍历，这个过程称为回表\n索引维护 为了维护索引的有序性，插入索引时，需要将索引插入合适的位置。如果数据所在页已经满了，需要重新 申请新的数据页，将部分数据移动过去。这个过程称为页分裂，性能会收到影响。\n数据库的自增主键，按照顺序插入，很容易保证有序性。\n如何减少回表次数 通过索引查询，需要回主键索引再查询一次，这就叫回表。\n覆盖索引\n如果要查的值直接在索引树中，比如查询主键id，这样直接就可以在索引树中获得，不需要回表。\n索引表中的数据已经满足查询要求，称为覆盖索引。\n最左前缀原则\n对于联合索引，按照从左至右的顺序匹配。比如建立（a,b）索引后，单独的 a 索引就没有必要的。 所以有时可以考虑联合索引的顺序。\n索引下推\n对于联合索引，mysql 5.6以后会推断索引中是否满足其他条件\n","id":1,"section":"posts","summary":"innodb 索引 在 innodb 引擎中，每个索引就是一颗 B+ 树。索引分为主键索引和非主键索引 主键索引：也叫 聚簇索引，叶子结点存放的就是整行数据 非主键索引：也叫 二级索","tags":null,"title":"Mysql Index","uri":"https://fearlessfe.github.io/blog/2022/07/mysql-index/","year":"2022"},{"content":"范型，traits和生命周期 范型 范型可以减少重复代码。\n以下例子是从 i32 和 char 类型的 vec 中找到最大值。\nfn largest_i32(list: \u0026amp;[i32]) -\u0026gt; i32 { let mut largest = list[0]; for \u0026amp;item in list { if item \u0026gt; largest { largest = item; } } largest } fn largest_i32(list: \u0026amp;[char]) -\u0026gt; char { let mut largest = list[0]; for \u0026amp;item in list { if item \u0026gt; largest { largest = item; } } largest } fn main() { let number_list = vec![34, 50, 25, 100, 65]; let result = largest_i32(\u0026amp;number_list); println!(\u0026quot;The largest number is {}\u0026quot;, result); let char_list = vec!['y', 'm', 'a', 'q']; let result = largest_char(\u0026amp;char_list); println!(\u0026quot;The largest char is {}\u0026quot;, result); } 使用范型重新定义函数\nfn largest\u0026lt;T\u0026gt;(list: \u0026amp;[T]) -\u0026gt; T { let mut largest = list[0]; for \u0026amp;item in list { if item \u0026gt; largest { largest = item; } } largest } fn main() { let number_list = vec![34, 50, 25, 100, 65]; let result = largest(\u0026amp;number_list); println!(\u0026quot;The largest number is {}\u0026quot;, result); let char_list = vec!['y', 'm', 'a', 'q']; let result = largest(\u0026amp;char_list); println!(\u0026quot;The largest char is {}\u0026quot;, result); } 上面的代码编译会报错，因为编译器无法确定类型 T 是否是可比较的。这是 traits 中的内容，会在下面介绍。\n范型的用法\n// struct struct Point\u0026lt;T\u0026gt; { x: T, y: T, } struct Point\u0026lt;T, U\u0026gt; { x: T, y: U, } // enum enum Option\u0026lt;T\u0026gt; { Some(T)， None, } enum Result\u0026lt;T, E\u0026gt; { OK(T), Err(E), } // 方法 impl\u0026lt;T\u0026gt; Point\u0026lt;T\u0026gt; { fn x(\u0026amp;self) -\u0026gt; \u0026amp;T { \u0026amp;self.x } } 范型不存在性能问题，rust在编译节点会收集具体的类型，然后生成对应的方法\ntraits，定义行为 trait 为类型定义行为。不同的类型去实现\npub trait Summary { fn summarize(\u0026amp;self) -\u0026gt; String; } pub struct NewsArticle { pub headline: String, pub lication: String, pub author: String, pub content: String, } impl Summary for NewsArticle { fn summarize(\u0026amp;self) -\u0026gt; String { format!(\u0026quot;{}, by {} ({})\u0026quot;, self.headline, self.author, self.location) } } pub struct Tweet { pub username: String, pub content: String, pub reply: bool, pub retweet: bool, } impl Summary for Tweet { fn summarize(\u0026amp;self) -\u0026gt; String { format!(\u0026quot;{}: {}\u0026quot;, self.username, self.content) } } 有些时候，可以提供默认实现，这样其余的类型就不需要实现了。\npub trait Summary { fn summarize(\u0026amp;self) -\u0026gt; String { String::from(\u0026quot;(Read more...)\u0026quot;) } } // 使用默认实现 impl Summary for NewsArticle {} 在 trait 中可以调用 trait 下面的其他方法\npub trait Summary { fn summarize_author(\u0026amp;self) -\u0026gt; String; fn summarize(\u0026amp;self) -\u0026gt; String { format!(\u0026quot;(Read more from {}...)\u0026quot;, self.summarize_author()) } } trait 作为函数参数\npub fn notify(item: \u0026amp;impl Summary) { println!(\u0026quot;Breaking news! {}\u0026quot;, item.summarize()); } 上面的写法是语法糖，下面是另外一种写法\npub fn notify\u0026lt;T: Summary\u0026gt;(item: \u0026amp;T) { println!(\u0026quot;Breaking news! {}\u0026quot;, item.summarize()); } 实现多个 trait\npub fn notify(item: \u0026amp;(impl Summary + Display)) { println!(\u0026quot;Breaking news! {}\u0026quot;, item.summarize()); } pub fn notify\u0026lt;T: Summary + Display\u0026gt;(item: \u0026amp;T) { println!(\u0026quot;Breaking news! {}\u0026quot;, item.summarize()); } 当函数参数有很多个 trait 的时候，函数签名可读性就会降低，这时候，可以使用 where\nfn some_function\u0026lt;T: Display + Clone, U: Clone + Debug\u0026gt;(t: \u0026amp;T, u: \u0026amp;U) -\u0026gt; i32 {} fn some_function\u0026lt;T, U\u0026gt;(t: \u0026amp;T, u: \u0026amp;U) -\u0026gt; i32 where T: Display + Clone, U: Clone + Debug trait 作为返回值\nfn returns_summarizable() -\u0026gt; impl Summary { Tweet { } } 目前只能返回特定的类型,下面的代码根据 switch 的值返回不同的类型，编译会报错\nfn returns_summarizable(switch: bool) -\u0026gt; impl Summary { if switch { NewsArticle { headline: String::from( \u0026quot;Penguins win the Stanley Cup Championship!\u0026quot;, ), location: String::from(\u0026quot;Pittsburgh, PA, USA\u0026quot;), author: String::from(\u0026quot;Iceburgh\u0026quot;), content: String::from( \u0026quot;The Pittsburgh Penguins once again are the best \\ hockey team in the NHL.\u0026quot;, ), } } else { Tweet { username: String::from(\u0026quot;horse_ebooks\u0026quot;), content: String::from( \u0026quot;of course, as you probably already know, people\u0026quot;, ), reply: false, retweet: false, } } } 修复 largest 函数\nfn largest\u0026lt;T: PartialOrd + Copy\u0026gt;(list: \u0026amp;[T]) -\u0026gt; T { let mut largest = list[0]; // Copy trait for \u0026amp;item in list { if item \u0026gt; largest { // PartialOrd trait largest = item; } } largest } fn main() { let number_list = vec![34, 50, 25, 100, 65]; let result = largest(\u0026amp;number_list); println!(\u0026quot;The largest number is {}\u0026quot;, result); let char_list = vec!['y', 'm', 'a', 'q']; let result = largest(\u0026amp;char_list); println!(\u0026quot;The largest char is {}\u0026quot;, result); } 利用 trait 控制特定方法的实现\nuse std::fmt::Display; struct Pair\u0026lt;T\u0026gt; { x: T, y: T, } impl\u0026lt;T\u0026gt; Pair\u0026lt;T\u0026gt; { fn new(x: T, y: T) -\u0026gt; Self { Self{x, y} } } // 只有实现 Display + PartialOrd trait 的类型才可以调用 cmp_display 方法 impl\u0026lt;T: Display + PartialOrd\u0026gt; Pair\u0026lt;T\u0026gt; { fn cmp_display(\u0026amp;self) { if self.x \u0026gt;= self.y { println!(\u0026quot;The largest member is x = {}\u0026quot;, self.x); } else { println!(\u0026quot;The largest member is y = {}\u0026quot;, self.y); } } } 同理，也可以选择性的实现其余 trait 如果当前type 实现了某个 trait 比如标准库中，为 T: Display 的类型实现了 ToString trait\nimpl\u0026lt;T: Display\u0026gt; ToString for T { } 所以只要实现了 Display trait 的类型都可以调用 to_string() 方法\n生命周期 使用生命周期避免 悬垂指针\n{ let r; { let x = 5; r = \u0026amp;x; } println!(\u0026quot;r: {}\u0026quot;, r); } 上面的代码编译会报错。因为 x 会被清理，但是 r 是 x 的引用。println 时，x 已经释放了。\nfn longest(x: \u0026amp;str, y:\u0026amp;str) -\u0026gt; \u0026amp;str { if x.len() \u0026gt; y.len() { x } else { y } } 上诉的 longest 编译会报错。因为无法确定到底返回的是 x 还是 y，需要加上 声明周期 标识。\n\u0026amp;i32 // 引用 \u0026amp;‘a i32 // 显示的生命周期 \u0026amp;‘a mut i32 // fn longest\u0026lt;'a\u0026gt;(x: \u0026amp;'a str, y: \u0026amp;'a str) -\u0026gt; \u0026amp;'a str { if x.len() \u0026gt; y.len() { x } else { y } } 接下来longest函数是如何限制生命周期的\nfn main() { let string1 = String::from(\u0026quot;long string is long\u0026quot;); // string1 声明周期大于 string2，代码正常运行 { let string2 = String::from(\u0026quot;xyz\u0026quot;); let result = longest(string1.as_str(), string2.as_str()); println!(\u0026quot;The longest string is {}\u0026quot;, result); } } // result 可能是 string2 的引用，print时， string2已经回收了 fn main() { let string1 = String::from(\u0026quot;long string is long\u0026quot;); let result; { let string2 = String::from(\u0026quot;xyz\u0026quot;); result = longest(string1.as_str(), string2.as_str()); } println!(\u0026quot;The longest string is {}\u0026quot;, result); } 声明周期注解的其他用法\n// 结构体 struct ImportantExcerpt\u0026lt;'a\u0026gt; { part: \u0026amp;'a str; } // 方法 impl\u0026lt;'a\u0026gt; ImportantExcerpt\u0026lt;'a\u0026gt; { fn announce_and_return_part(\u0026amp;self, announcement: \u0026amp;str) -\u0026gt; \u0026amp;str { println!(\u0026quot;Attention please: {}\u0026quot;, announcement); self.part } } 静态生命周期 'static，在程序运行期间都是有效的。比如字符串字面量\n范型，trait 和 生命周期\nuse std::fmt::Display; fn longest_with_an_anno\u0026lt;'a, T\u0026gt;( x: \u0026amp;'a str, y: \u0026amp;'a str, ann: T ) -\u0026gt; \u0026amp;'a str where T: Display, { println!(\u0026quot;Announcement! {}\u0026quot;, ann); if x.len() \u0026gt; y.len() { x } else { y } } ","id":2,"section":"posts","summary":"范型，traits和生命周期 范型 范型可以减少重复代码。 以下例子是从 i32 和 char 类型的 vec 中找到最大值。 fn largest_i32(list: \u0026amp;[i32]) -\u0026gt; i32 { let mut largest = list[0]; for \u0026amp;item in list { if item \u0026gt; largest { largest =","tags":null,"title":"Rust Traits","uri":"https://fearlessfe.github.io/blog/2022/06/rust-traits/","year":"2022"},{"content":"常用集合 vector： 向量 string: 字符串 hash map vector 初始化向量\n// 未赋值，必须显示的制定类型 let v: Vec\u0026lt;i32\u0026gt; = Vec::new(); // 如果需要初始化并赋值，可以使用 vec! 宏 // rust会自动推断类型，默认为 i32 let v = vec![1,2,3] 更新向量\n// 未赋值，必须显示的制定类型 let v: Vec\u0026lt;i32\u0026gt; = Vec::new(); v.push(2) // 当 v 的作用域结束后，vec会自动释放 读取向量中的元素\nlet v = vec![1,2,3,4,5]; let third: \u0026amp;i32 = \u0026amp;v[2]; println!(\u0026quot;The third element is {}\u0026quot;, third); // get 方法返回的是 Option\u0026lt;\u0026amp;T\u0026gt; match v.get(2) { Some(third) =\u0026gt; println!(\u0026quot;The third element is {}\u0026quot;, third), None =\u0026gt; println!(\u0026quot;There is no third element.\u0026quot;), } 向量所有权.下面的代码会报错。 first 是第一个元素的不可变引用，当向 vec 中push 元素时，可能会引起扩容，导致 first 引用错误的内存地址。所以下面的代码无法编译通过。\nlet mut v = vec![1, 2, 3, 4, 5]; let first = \u0026amp;v[0]; v.push(6); println!(\u0026quot;The first element is: {}\u0026quot;, first); 遍历 vec\nlet v = vec![100, 20,33]; // 不可变引用 for i in \u0026amp;v { println!(\u0026quot;{}\u0026quot;, i); } // 可变引用 for i in \u0026amp;mut v { *i += 50; } 使用 Enum 存储多个类型\nenum SpreadsheetCell { Int(i32), Float(f64), Text(String), } let row = vec![ SpreadsheetCell::Int(3), SpreadsheetCell::Text(String::from(\u0026quot;blue\u0026quot;)), SpreadsheetCell::Float(10.12), ]; String 创建 String。String 是 utf-8 编码。\nlet mut s = String::new(); let data = \u0026quot;initial contents\u0026quot;; let s1 = data.to_string(); 更新 string\nlet mut s = String::new(); // push_str s.push_str(\u0026quot;hello\u0026quot;); s.push('l'); let s1 = String::from(\u0026quot;Hello \u0026quot;); let s2 = String::from(\u0026quot;world!\u0026quot;); let s3 = s1 + \u0026amp;s2; // s1 的所有权移到了 s3 在标准库中， + 操作的签名如下。第一个参数是 self,有所有权的转移。 直接将 s 的内容追加到 self 中。\nfn add(self, s: \u0026amp;str) -\u0026gt; String {} 多个字符串拼接可以用 format! 宏. format! 不会拿字符串的所有权\nlet s1 = String::from(\u0026quot;tic\u0026quot;); let s2 = String::from(\u0026quot;tac\u0026quot;); let s3 = String::from(\u0026quot;toe\u0026quot;); let s = format!(\u0026quot;{}-{}-{}\u0026quot;, s1, s2, s3); 字符串索引。我们不能直接通过下标获取字符串中的某个字符 以下语句是非法的。\nlet s1 = String::from(\u0026quot;hello\u0026quot;); let h = s1[0]; let h = \u0026amp;s1[..][0]; 遍历字符串. chars() 和 bytes().\nlet s1 = String::from(\u0026quot;hello\u0026quot;); for c in s1.chars() { println!(\u0026quot;{}\u0026quot;,c ); } for b in s1.bytes() { println!(\u0026quot;{}\u0026quot;,b ); } Hash Map 新建 Hash Map\nuse std::collections::HashMap; let mut scores = HashMap.new(); scores.insert(String::from(\u0026quot;blue\u0026quot;),10); scores.insert(String::from(\u0026quot;yellow\u0026quot;),50); // keys 和 values 构建 map let keys = vec![String::from(\u0026quot;blue\u0026quot;), String::from(\u0026quot;yellow\u0026quot;)]; let values = vec![10, 50]; let mut map: HashMap\u0026lt;_, _\u0026gt; = keys.into_iter().zip(values.into_iter()).collect(); 插入的key和value会根据语义转移所有权\nmap 的值也可以是引用，这样值的所有权不回转移。但是要注意生命周期，在map有限期间都能访问 到引用的值。\nuse std::collections::HashMap; let mut map = HashMap.new(); let field_name = String::from(\u0026quot;Favorite color\u0026quot;); let field_value = 32; // field_name 所有权转移，field_value是 copy map.insert(field_name, field_value); let value = map.get(\u0026amp;field_name); // value 是 Some(\u0026amp;T) 类型 for (key, value) in \u0026amp;map { println!(\u0026quot;{}: {}\u0026quot;, key, value); } 更新hash map\nuse std::collections::HashMap; let mut map = HashMap.new(); let field_name = String::from(\u0026quot;Favorite color\u0026quot;); let field_value = 32; // field_name 所有权转移，field_value是 copy map.insert(field_name, field_value); // 覆盖原来的值 map.insert(String::from(\u0026quot;Favorite color\u0026quot;), 10); map.insert(String::from(\u0026quot;Blue\u0026quot;), 25); // 判断key是否存在，不存在则设置新的值,存在则忽略 // entry 返回的是值的可变引用 map.entry(String::from(\u0026quot;Favorite color\u0026quot;)).or_insert(50); // 在原值的基础上操作 let value = map.entry(String::from(\u0026quot;Favorite color\u0026quot;)).or_insert(50); *value += 1; ","id":3,"section":"posts","summary":"常用集合 vector： 向量 string: 字符串 hash map vector 初始化向量 // 未赋值，必须显示的制定类型 let v: Vec\u0026lt;i32\u0026gt; = Vec::new(); // 如果需要初始化并赋值，可以使用 vec! 宏 // rust会自动","tags":null,"title":"Rust Collections","uri":"https://fearlessfe.github.io/blog/2022/06/rust-collections/","year":"2022"},{"content":"结构体 定义,初始化和赋值 定义结构体使用 struct 关键字\nstruct User { active: bool, username: String, email: String, sign_in_count: u64, } fn main() { let user1 = User { email: String::from(\u0026quot;someone@example.com\u0026quot;), username: String::from(\u0026quot;someusername123\u0026quot;), active: true, sign_in_count: 1, }; user1.email = String::from(\u0026quot;someone@example.com\u0026quot;); } 整个结构体都是可以修改的，不能将某个字段标记为不可修改。\n结构体赋值和更新\nstruct User { active: bool, username: String, email: String, sign_in_count: u64, } fn main() { let user1 = User { email: String::from(\u0026quot;someone@example.com\u0026quot;), username: String::from(\u0026quot;someusername123\u0026quot;), active: true, sign_in_count: 1, }; user1.email = String::from(\u0026quot;someone@example.com\u0026quot;); // 类似于 js 的解构赋值 user2 = User { email: String::from(\u0026quot;someone@example.com\u0026quot;), ..user1 }; } tuple struct 和 unit struct\nstruct Color(i32,i32,i32) struct Unit; fn main() { let black = Color(0,0,0); let unit = Unit; } 结构体数据的所有权 定义 User 结构体时，email 数据类型是 String，这样每个结构体都有自己的数据。 结构体的字段也可以是引用，但是这样就需要标识声明周期。\n方法 方法定义在结构体的上下文中，第一个参数总是 self\n#[derive(Debug)] struct Rectangle { width: u32, height: u32, } // 在结构体上下文中，Self 就是当前结构体（Rectangle）的别名 // \u0026amp;self 是 self: \u0026amp;Self 的简写 // 如果需要拿到 Self 的所有权，则传 self,等效于 self: Self // 如果需要可变引用，则传 \u0026amp;mut self, 等效于 self: \u0026amp;mut Self impl Rectangle { fn area(\u0026amp;self) { self.width * self.height } } fn main() { let rect1 = Rectangle { width: 30, height: 50, }; println!( \u0026quot;The area of the rectangle is {} square pixels.\u0026quot;, rect1.area() ); } 关联函数 在结构体的 impl 块中，第一个参数不为 self 的函数称为关联方法。如 String::from 就是 String 的关联方法。\nimpl Reactangle { fn square(size: u32) -\u0026gt; Reactangle { Rectangle { width: size, height: size, } } } fn main() { Reactangle::square(20); } 一个结构体可以有多个 impl 块，这在语法上是正确的。多个 impl 块在范型和traits中很有用。\n","id":4,"section":"posts","summary":"结构体 定义,初始化和赋值 定义结构体使用 struct 关键字 struct User { active: bool, username: String, email: String, sign_in_count: u64, } fn main() { let user1 = User { email: String::from(\u0026quot;someone@example.com\u0026quot;), username: String::from(\u0026quot;someusername123\u0026quot;), active: true, sign_in_count: 1, }; user1.email = String::from(\u0026quot;someone@example.com\u0026quot;); } 整个结构体都是可以修改的，不","tags":null,"title":"Rust Struct","uri":"https://fearlessfe.github.io/blog/2022/06/rust-struct/","year":"2022"},{"content":"所有权系统 所有权是rust管理内存的一系列的规则。\nrust 的每个值都有一个被称为 \u0026lsquo;owner\u0026rsquo; 的变量 每个时刻只能有一个 owner 当 owner 出作用域后，值会被丢弃 String 类型 字符串字面量是不可变的，如果需要可变字符串，可以使用 String 类型，它的内存会分配在堆上\nfn main() { let mut s = String.from(\u0026quot;Hello\u0026quot;) s.push_str(\u0026quot;, world!\u0026quot;); } 变量与值的交互 下面的代码是简单的复制语句。首先我们需要了解 String 类型在栈上存的是一个简单的结构体 存储着字符串的长度，容量和指向实际内容的指针。\nfn main() { let x = 5; let y = x; let s1 = String.from(\u0026quot;hello\u0026quot;); let s2 = s1; } move 语义 上面代码中执行 s2 = s1 后，rust 只会复制栈上的内容，堆上的内容没有变化。 同时 s1 将失效，可以理解为数据的所有权从 s1 转移到了 s2。这就是 move 语义， 代表所有权的转移。\nclone 语义 如果需要 s1 和 s2 同时有效，需要使用 clone 方式，这会深度拷贝，不仅拷贝栈上的值， 也会拷贝堆上的值。代码如下\nfn main() { let s1 = String.from(\u0026quot;hello\u0026quot;); let s2 = s1.clone(); } copy 语义 最开始的代码中，执行 y = x 后，x 和 y 都是有效的。这是因为rust为栈上的数据类型默认 实现了 Copy 语义，直接复制栈上的数据。\n需要注意的是，这个只有栈上数据类型才有copy语义。一下数据类型都自动实现了copy语义\n整数和浮点数，如 u32，f64 布尔类型 字符类型 元组，其中的每个类型都实现了 Copy，(i32,u32)可以。(i32,String)不行 数组，和元组类似 所有权和函数 函数传参和变量赋值类似，要么是 move，要么是 copy。\nfn main() { let s = String::from(\u0026quot;hello\u0026quot;); // s comes into scope takes_ownership(s); // s's value moves into the function... // ... and so is no longer valid here let x = 5; // x comes into scope makes_copy(x); // x would move into the function, // but i32 is Copy, so it's okay to still // use x afterward } // Here, x goes out of scope, then s. But because s's value was moved, nothing // special happens. fn takes_ownership(some_string: String) { // some_string comes into scope println!(\u0026quot;{}\u0026quot;, some_string); } // Here, some_string goes out of scope and `drop` is called. The backing // memory is freed. fn makes_copy(some_integer: i32) { // some_integer comes into scope println!(\u0026quot;{}\u0026quot;, some_integer); } // Here, some_integer goes out of scope. Nothing special happens. 函数返回值 函数返回值也会有所有权的转移\nfn main() { let s1 = gives_ownership(); // gives_ownership moves its return // value into s1 let s2 = String::from(\u0026quot;hello\u0026quot;); // s2 comes into scope let s3 = takes_and_gives_back(s2); // s2 is moved into // takes_and_gives_back, which also // moves its return value into s3 } // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing // happens. s1 goes out of scope and is dropped. fn gives_ownership() -\u0026gt; String { // gives_ownership will move its // return value into the function // that calls it let some_string = String::from(\u0026quot;yours\u0026quot;); // some_string comes into scope some_string // some_string is returned and // moves out to the calling // function } // This function takes a String and returns one fn takes_and_gives_back(a_string: String) -\u0026gt; String { // a_string comes into // scope a_string // a_string is returned and moves out to the calling function } 引用和借用 如果我们只想将值传递给函数，但是不影响所有权，我们需要用到引用。\n引用就像一个指针，它指向的地址就是实际的内容；但和指针不同的是，引用可以保证指向的有效的值。\nfn main() { let s1 = String.from(\u0026quot;Hello\u0026quot;); let len = calculate_length(\u0026amp;s1); println!(\u0026quot;The length of '{}' is {}.\u0026quot;, s1, len); } // 参数 s 为一个指针，指针指向的是变量 s1 fn calculate_length(s: \u0026amp;String) -\u0026gt; usize { s.len() } // \u0026amp; 表明是一个引用，没有所有权。所以函数结束后，所有权没有变化 我们将创建引用的行为称为借用。引用默认也是不可变的，如果在函数中修改引用就会报错。\n如果需要修改引用，应创建可变引用。\nfn main() { let mut s = String.from(\u0026quot;hello\u0026quot;); change(\u0026amp;mut s); } fn change(s: \u0026amp;mut String) { some_string.push_str(\u0026quot;, world\u0026quot;); } 需要注意的是，在某一时刻只能有一个可变引用。\n同一代码块中，需要注意 不可变引用和可变引用的生命周期。一下代码是正常的\nfn main() { let mut s = String::from(\u0026quot;hello\u0026quot;); let r1 = \u0026amp;s; // no problem let r2 = \u0026amp;s; // no problem println!(\u0026quot;{} and {}\u0026quot;, r1, r2); // variables r1 and r2 will not be used after this point let r3 = \u0026amp;mut s; // no problem println!(\u0026quot;{}\u0026quot;, r3); } 引用的准则\n任意时刻，你可有一个可变引用或任意多的不可变引用。 引用一定是有效的 切片类型 切片让你引用一块连续的区间，而不是所有的集合。切片是引用，所以没有所有权。\n现在有一个需求，需要找到字符串中的第一个单词。我们需要考虑该函数返回什么？可以考虑返回 第一个单词的位置。\nfn main() { let mut s = String::from(\u0026quot;hello world\u0026quot;); let word = first_word(\u0026amp;s); // word will get the value 5 s.clear(); // this empties the String, making it equal to \u0026quot;\u0026quot; // word still has the value 5 here, but there's no more string that } fn first_world(s: \u0026amp;String) -\u0026gt; usize { let bytes = s.as_bytes(); for (i, \u0026amp;item) in bytes.iter().enumerate() { if item = b' ' { return i; } } s.len() } 上述代码的问题就是返回的位置是没有意义的，即使字符串清空了，位置还是存在。 所以可以考虑切片。\nfn main() { let s = String::from(\u0026quot;hello\u0026quot;); let slice = \u0026amp;s[0..2]; // index [0, 2)，不包含索引2 let slice = \u0026amp;s[..2]; } 切片的位置必须是有效的 UTF-8 的分界，否则会出错。\nstring slice 的类型是 \u0026amp;str\nfn first_word(s: \u0026amp;String) -\u0026gt; \u0026amp;str { let bytes = s.as_bytes(); for (i, \u0026amp;item) in bytes.iter().enumerate() { if item == b' ' { return \u0026amp;s[0..i]; } } \u0026amp;s[..] } 前面说到字符串字面量直接存储在二进制文件中，所以字符串字面量就是字符串切片类型，\u0026amp;str. 除了字符串有切片，数组也有切片\nlet a = [1,2,3,4,5]; let slice = \u0026amp;a[1..3]; assert_eq!(slice, \u0026amp;[2, 3]); ","id":5,"section":"posts","summary":"所有权系统 所有权是rust管理内存的一系列的规则。 rust 的每个值都有一个被称为 \u0026lsquo;owner\u0026rsquo; 的变量 每个时刻只能有一个 owner 当 owner 出作用域后，值会被丢弃 String 类型 字符串","tags":null,"title":"Rust Ownership","uri":"https://fearlessfe.github.io/blog/2022/06/rust-ownership/","year":"2022"},{"content":"通用概念 变量和可变性 变量 rust 中变量默认是不可变的。下面的代码片段会报错，因为 x 是不可变的，不能重新赋值。 如果需要声明可变变量，需要加上关键字 mut\nfn main() { let x = 5; // let mut x = 5; println!(\u0026quot;x is: {}\u0026quot;, x ) x = 6; println!(\u0026quot;x is: {}\u0026quot;, x ) } 常量 rust 中用 const 来声明常量，常量是不可变的。 常量的值在编译阶段就需要确定，因此不能是运行阶段计算出来的值。\n常量的值在整个程序运行期间都是有效的。\n变量遮蔽 用 let 声明相同的变量，会屏蔽前面的同名变量。 下面的代码用num类型的变量遮蔽了前面的字符串类型变量。\nfn main() { let x = \u0026quot; \u0026quot;; let x = x.len(); println!(\u0026quot;x is: {}\u0026quot;, x ) } 数据类型 rust 中每个值都有一个确定的类型。接下来我们将了解一下两种数据类型子集：标量和复合变量。\n标量类型 标量类型代表一个单一的值。rust 有四种标量类型： 整数，浮点数，布尔和字符。\n整数类型：i是有符号，u是无符号。长度 8-16-32-64-128. isize 和 usize 类型和系统有关 32 位系统代表 i32或u32，64位系统代表 i64或u64.\nfn main() { let a: i32 = 98_222; let b: i32 = 0xff; let c: i32 = 0x77; let d: i32 = 0b1111_0000; let e: u8 = b'A'; // 代表 Byte，与u8一致 } 复合类型 将多个值组合成一个类型。rust原生类型有元组和数组。\n元组类型 元组将多个不同类型的值组合起来，元组的长度是固定的。\nfn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); // 通过解构赋值 let (x,y,z) = tup; // 通过下标 let a = tup.0; let b = tup.1; } 数组类型 数组中只能有一个类型，而且长度也是固定的。越界访问会报错。\nfn main() { let a: [i32; 5] = [1, 2, 3, 4, 5]; // 通过下标 let first = a[0]; let second = a[1]; } 函数 rust 用 fn 声明函数， main 函数是程序的入口。函数命名风格为 snake_case。\n函数参数必须要明确类型\nfn main() { println!(\u0026quot;Hello, world!\u0026quot;); another_function(5, 'h'); } fn another_function(x: i32, unit_label: char) { println!(\u0026quot;Another function.\u0026quot;); } 语句和表达式 语句没有返回值，表达式有返回值。\nfn main() { let y = 6; // 声明语句 // 大括号中是一个表达式，最后一个没有逗号，代表返回值 // y 的值是4 let y = { let x = 3; x + 1 }; } 带返回值的函数 fn five() -\u0026gt; i32 { 5 } fn main() { let x = five(); println!(\u0026quot;The value of x is: {}\u0026quot;, x); } 控制流 if 表达式 if 是表达式，也会有返回值。\nfn main() { let number = 3; if number \u0026lt; 5 { println!(\u0026quot;condition was true\u0026quot;); } else { println!(\u0026quot;condition was false\u0026quot;); } let condition = true; let number = if condition { 5 } else { 6 }; } loop 循环 break 跳出当前循环。 loop 也是表达式，也有可以有返回值。\nfn main() { let mut count = 0; 'counting_up: loop { println!(\u0026quot;count = {}\u0026quot;, count); let mut remaining = 10; loop { println!(\u0026quot;remaining = {}\u0026quot;, remaining); if remaining == 9 { break; } if count == 2 { break 'counting_up; } remaining -= 1; } count += 1; } println!(\u0026quot;End count = {}\u0026quot;, count); } while 循环\nfn main() { let a = [10, 20, 30, 40, 50]; let mut index = 0; while index \u0026lt; 5 { println!(\u0026quot;the value is: {}\u0026quot;, a[index]); index += 1; } } for..in循环数组\nfn main() { let a = [10, 20, 30, 40, 50]; for element in a { println!(\u0026quot;the value is: {}\u0026quot;, element); } for number in (1..4).rev() { println!(\u0026quot;{}!\u0026quot;, number); } println!(\u0026quot;LIFTOFF!!!\u0026quot;); } ","id":6,"section":"posts","summary":"通用概念 变量和可变性 变量 rust 中变量默认是不可变的。下面的代码片段会报错，因为 x 是不可变的，不能重新赋值。 如果需要声明可变变量，需要加上关键字 mut","tags":null,"title":"Rust Basic","uri":"https://fearlessfe.github.io/blog/2022/06/rust-basic/","year":"2022"},{"content":"类组件与函数组件 函数组件能更好的复用逻辑\n高阶组件缺点：组件静态方法，ref 传递\nOOP思想与函数式思想，组合优于继承\nsetState 是否为异步 在 React 生命周期和合成事件中，是批量更新，表现为异步。在 addEventListener, setTimeout, setInterval 中，不受 React 控制，是同步的\n为什么设置为异步更新？保持内部一致性，props 无法同步；为后面的 React 异步设计打下基础。\nReact 跨层级通信 确定主题，列举场景\n父子: props 子父: 回调函数 兄弟: 公共父组件 无关系: Context，状态管理工具 状态管理 FLUX 单项数据流\nRedux 如何处理副作用：Dispatch 中间件处理副作用 或者 在 Reducer 中处理副作用\n分形架构：如果子组件能够以同样的结果，作为一个应用使用\nRedux：单一数据源，reducer纯函数， store 只读\nMobx：监听方式，Mobx5 前，采用 Object.defineProperty, 5 之后采用 Proxy 方案\nVirtual DOM 工作原理 XHP 防止 XSS，但是状态更新需要重新渲染全部页面，影响用户体验。\nReact.createElement 返回的是一个 js 的对象。\ndiff 函数，计算状态变更前后虚拟 DOM 树的差异 渲染函数，渲染整个虚拟 DOM 树或者处理差异点 所以 React 和 ReactDOM 是两个库\nVirtual DOM 的优势\n大量直接操作 DOM 容易引起网页性能下降，这样的情况下，React 基于虚拟DOM的diff处理与皮处理操作可降低 DOM 的操作范围和频次，提升页面性能\n防止 XSS\n跨平台成本低\nVirtual DOM 的劣势\n内存，高性能场景难以优化\nReact Diff 算法与其他框架的不同 更新时机：setState, forceUpdate, hooks调用等 遍历算法：深度优先遍历，保证组件生命周期的一致性 优化策略：树的遍历，复杂度为O(n^3)。React 使用分治的思想，将复杂度将为O(n) 从 树，组件，元素三个方向来优化\n忽略节点跨层级操作场景，对树进行分层比较，两棵树只对同一层次节点进行比较 组件的 Class 是同一类型，则进行树比对 同一层级的节点，通过 key 的方式直接移动 Fiber 机制下节点与树分别采用 FiberNode 和 FiberTree 进行重构\ncurrent 树与 workInProgress 两株树双缓冲，直接更新 current 树的指针\nVue2.0 使用 snabbdom,整体思路与 React 相同。\nReact 渲染流程 核心 阶段 调度 事务 协调，Reconciler\nStack Reconciler 是 React 15 及以前版本的渲染方案，核心是以递归的方式逐级调度栈中子节点到父节点的渲染\nFiber Reconciler 是 React 16 及以后版本的渲染方案，核心设计是增量渲染，将渲染工作分隔为多区块，将其分散到多个帧中执行\nReact 渲染的整体策略是递归，并通过事务建立 React 与虚拟 DOM 的联系并完成调度\n渲染过程大概一致，但协调不同\nReact 渲染异常 是什么？怎么解决？\n预防： ?. 操作符 兜底： 高阶组件，hooks\n如何分析和调优性能瓶颈 性能指标，统计数据\n避免重复渲染 React Hooks 使用限制 问题 组件难以复用状态逻辑 类难以编译优化 类组件逻辑杂乱\n限制 不要嵌套调用hook 只能在函数式组件中调用hook\nuseEffect 与 useLayoutEffect 共同点\n都是用于处理副作用，如DOM事件\n不同点\n直接操作 DOM 样式，或者引起页面闪烁，使用 useLayoutEffect\nuseLayoutEffect：会在所有 DOM 变更之后同步调用，所以可以读取 DOM 布局并同步触发重渲染，但计算量较大时，会造成卡顿\nReact-Router 实现原理及工作方式 实现原理\nhash 路由 history\nReact 工具库 初始化： create-react-app, umi 路由： react-router css: css in js: styled-component, classnames 基础组件： antd 状态管理：redux， mobx 构建： webpack， rollup， esbuild 检查： ESLint， prettier 测试： jest, react-testing-library, react-hooks-testing-library\n","id":7,"section":"posts","summary":"类组件与函数组件 函数组件能更好的复用逻辑 高阶组件缺点：组件静态方法，ref 传递 OOP思想与函数式思想，组合优于继承 setState 是否为异步 在 React 生命周期和","tags":null,"title":"React 笔记","uri":"https://fearlessfe.github.io/blog/2022/05/react/","year":"2022"},{"content":"最近面试 golang 被问到，golang 里面的 mutex 是什么类型的锁。很无奈，没了解过相关知识，没有答出来。\n在 google 上一搜，对 Java 中锁介绍的资料最多，从不同的角度出发，锁的分类也不同。下图引用了美图技术博客的分类\n下面对其中的几类锁做一下简单的介绍，然后看看 mutex 是什么类型的锁。\n乐观锁，悲观锁 乐观锁和悲观锁是以是否锁住同步资源来区分的。\n很显然，mutex 是悲观锁，goroutine 获取锁后，相关的资源也会锁住，不让其余 goroutine 操作。\n那么乐观锁是怎么处理多个 goroutine 的竞争关系呢？答案就是 CAS（Campare And Swap），先比较，再交换。 go里面的 atomic 包提供了相关方法,以 CompareAndSwapInt32 为例，该方法接受3个参数：\n内存地址,addr 需要比较的值,old 新的值,new 将 addr 处的值于 old 比较，如果相同，则将 addr 的值设置为 new，否则就返回 false。\natomic.CompareAndSwapInt32(\u0026amp;addr, old, new) CAS 的性能会远高于锁，但是 CAS 也会有一些不适用的情况。\nABA 问题：CAS 只是比较值是否改变，如果该地址初始值为 A，别的 goroutine 将值改为 B，后来🈶️有 goroutine 将值改为 A。CAS 是不能判断这种变化的，可能会产生一些问题。 只能对一个变量进行操作，无法保证多个变量的原子性。 除了 CAS，使用版本号也可以实现乐观锁。\n版本号的原理是在数据中加一个 version 字段，每次字段改变后， version 加 1。每次更新时，先比较当前版本于数据目前的版本是否一致，否则就不能更新数据。\n公平锁，非公平锁 按照多个 goroutine 竞争锁的时候，是否按照 FIFO 的顺序来获得锁，可以分为公平锁和非公平锁。\nmutex 的实现经历了多个版本，早期版本时按照 FIFO 的方式来实现的，是公平锁。但后来的版本为了性能，该为了非公平锁。详细资料可参考相关文章。\n目前 mutex 的实现是新的 goroutine 进来会先插队，插队失败后会排队。所以 mutex 是非公平锁。\n其余类型 mutex 是互斥锁，只能由单个 gouroutine 获取，而且不能重复的去获取同一把锁。所以 mutex 是不可重入锁，排它锁。\n总结 mutex 可以是 悲观锁，非公平锁，不可重入锁和排它锁。\n参考资料 【BAT面试题系列】面试官：你了解乐观锁和悲观锁吗？\n不可不说的Java“锁”事\n","id":8,"section":"posts","summary":"最近面试 golang 被问到，golang 里面的 mutex 是什么类型的锁。很无奈，没了解过相关知识，没有答出来。 在 google 上一搜，对 Java 中锁介绍的资料最多，从不同的角度","tags":null,"title":"golang 里面的 mutex 是什么类型的锁？","uri":"https://fearlessfe.github.io/blog/2022/02/%E6%82%B2%E8%A7%82%E9%94%81%E4%B9%90%E8%A7%82%E9%94%81/","year":"2022"},{"content":"为什么要写这篇文章 有一段时间 nodejs 工作经历，面试总是被问到 Event Loop,虽然看过官网上的文章，奈何总是记不住，面试也答不上来。因此，写这篇文章来加深印象。原文请👇这里\n什么是 Event Loop 虽然 Javascript 是单线程的，但是 Event Loop 让 Nodejs 能够执行非阻塞的 I/O。\n现代内核都是多线程的，它们可在后台执行多个操作。但其中一个操作完成后，内核通知 Nodejs 以便将相应的回调添加到轮询队列，最后回调会被执行。\nEvent Loop简介 当 Nodejs 运行时，它会初始化事件循环，执行输入的脚本，脚本中可能会调用异步的 API，timer 函数或 process.nextTick(),然后开始事件循环。\n下图（来源于原文）简单的描述了事件循环操作顺序。\n┌───────────────────────────┐ ┌─\u0026gt;│ timers │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ pending callbacks │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ idle, prepare │ │ └─────────────┬─────────────┘ ┌───────────────┐ │ ┌─────────────┴─────────────┐ │ incoming: │ │ │ poll │\u0026lt;─────┤ connections, │ │ └─────────────┬─────────────┘ │ data, etc. │ │ ┌─────────────┴─────────────┐ └───────────────┘ │ │ check │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ └──┤ close callbacks │ └───────────────────────────┘\n图中每个盒子代表事件循环中一个阶段\n每个阶段都是一个队列，按照 FIFO 的方式执行回调函数。事件循环进入其中一个阶段后，首先会执行该阶段特定的操作。然后执行该阶段队列中的回调，知道队列中回调全部执行完或者达到最大的回调限制，然后事件循环进入下一个阶段。\n由于这些操作可能会产生新的事件，而轮询阶段（poll phase）新的事件由内核加入到队列，因此处理轮询事件时也会有新的事件加入到队列中。因此，长时间运行的回调会让轮询阶段的时间远超过计时器的阈值。\n阶段概览 timers: 这个阶段执行 setTimeout() 和 setInterval() 的回调 pending callbacks：执行推迟到下一个循环的 I/O 回调 idle,prepare: 仅供内部使用 poll（轮询）: 检索新的 I/O 事件；执行 I/O 相关的回调（几乎所有的回调，除了关闭回调，定时器调度的回调和setImmediate()）,节点会在适当的时候阻塞。 check：setImmediate()的回调在这里执行。 close callbacks: 关闭的回调，比如socket.on('close',...) 在事件循环之间，Nodejs 会检查它是否正在等待异步 I/O 或计时器。如果没有，则退出。（这里退出应该是指退出 nodejs 程序）。\n阶段详情 timers 计时器可以指定一个阈值，到达阈值后执行回调，而不是决定回调执行的确切时间。计时器的回调会在指定的时间过后尽可能早的执行，但是回调的执行可能会延迟。\n轮询阶段控制计时器回调的执行\n举个例子，定时器在100ms后执行回调，然后一个异步读取文件会花 95ms\nconst fs = require('fs'); function someAsyncOperation(callback) { fs.readFile('/path/to/file', callback) } const timeoutScheduled = Date.now(); setTimeout(() =\u0026gt; { const delay = Date.now() - timeoutScheduled console.log(`${delay}ms have passed since I was scheduled`) }, 100) // someAsyncOperation takes 95ms someAsyncOperation(() =\u0026gt; { const startCallback = Date.now() // do something will take 10ms while(Date.now() - startCallback \u0026lt; 10) { // do nothing } }) 当事件循环进入轮询阶段，此时队列是空的，所以会等待一直达到最近的计时器阈值。 95ms 后，读取文件的操作完成，回调进入轮询阶段的队列，然后花 10ms 执行回调。执行完成后，队列为空，这时候到达了 100ms 的阈值，因此会回到 timer 阶段执行定时器的回调。所以定时器的回调会在 105ms 后被执行，而不是 100ms。\n为了防止轮询阶段过长使得事件循环陷入饥饿，libuv 对轮询阶段设置处理事件的最大值\npending callbacks 这个阶段执行系统操作的回调，比如 TCP error。比如一个 TCP 连接收到了 ECONNREFUSED,一些 *nix 的系统想要 report 这个错误。这些事件的回调会在这个阶段执行。\nidle prepare 这个阶段仅供内部使用\npoll(轮询) 轮询阶段主要有两个功能：\n计算应该阻塞和轮询 I/O 的时间 处理轮询队列的事件 当事件循环进入 轮询阶段并且没有定时器，将发生以下两件事之一：\n如果轮询队列不是空的，那事件循环会按顺序同步的执行队列中的事件，知道队列为空或者达到最大的事件限制 如果队列为空，则可能发生下列两件事之一： 如果有 setImmediate() 事件，事件循环会结束轮询阶段，进入 check 阶段，执行该阶段的回调。 如果没有 setImmediate() 事件，事件循环会等待回调被加入到队列，然后立即执行回调 如果轮询队列为空，事件循环会检查是否达到定时器的阈值。如果有，事件循环会回到 timer 阶段，执行定时器的回调。\ncheck 这个阶段是在轮询阶段结束后执行该阶段的回调。\nsetImmediate()是一个特别的定时器，在单独的阶段执行。\n一般来说，代码执行后，事件循环会最终达到轮询阶段，等待新来的链接，请求等。如果有 setImmediate() 而且轮询阶段处于空闲状态，轮询阶段会结束，然后进入 check 阶段执行 setImmediate() 的回调。\nclose callback 如果套接字或句柄被突然关闭（例如 socket.destroy()）,此阶段会 emit \u0026lsquo;close\u0026rsquo; 事件。否则会通过 process.nextTick()\nsetImmediate() VS setTimeout() setImmediate() 和 setTimeout() 比较类似，但是根据调用时间不同而有不同的表现。\nsetImmediate() 设计为 轮询阶段结束后调用 setTimeout() 达到设定的阈值后调用 如果两者都在主模块中调用，那么两者的顺序是不固定的，两者顺序取决于处理器的性能。\nsetTimeout(() =\u0026gt; { console.log('timeout) }, 0) setImmediate(() =\u0026gt; { console.log('immediate) }, 0) 如果在 I/O 事件中调用，则 setImmediate 总是先执行\nconst fs = require('fs'); fs.readFile(\u0026quot;\u0026quot;, () =\u0026gt; { setTimeout(() =\u0026gt; { console.log('timeout) }, 0) setImmediate(() =\u0026gt; { console.log('immediate) }, 0) }) process.nextTick() 理解 nextTick process.nextTick() 没有在图中展示，即使这是一个异步的 API。因为 nextTick 不属于事件循环。\n在某个阶段的任意时刻调用 process.nextTick()，它的回调会在事件循环继续之前执行。这会出现一些坏的情况，比如在 process.nextTick() 递归调用 process.nextTick()，这会使得事件循环无法继续。\n为什么需要 nextTick nextTick 一部分的设计理念是 API 应该始终是异步的，即使它不是。以下面的代码为例\nfunction apiCall(arg, callback) { if (typeof arg != 'string') { return process.nextTick(callback, new TypeError('args should be string')) } } 这样回调会在所有用户的 code 执行完毕后，在进入事件循环之前才执行。\n下面是一个真正的例子\nconst server = net.createServer(() =\u0026gt; {}).listen(8080) server.on('listening', () =\u0026gt; {}) 只有绑定端口后， \u0026rsquo;listening\u0026rsquo; 回调才会执行。但问题是那时候 \u0026rsquo;listening\u0026rsquo; 回调还没设置。 所以 \u0026rsquo;listening\u0026rsquo; 回调放在 nextTick() 中。\nprocess.nextTick() VS setImmediate() 这两者比较类似，但是名字有点让人困惑\nprocess.nextTick() 在当前阶段执行 setImmediate() 在时间循环中执行 建议开发者在所有情况下都使用 setImmediate()\n为什么需要 process.nextTick() 主要有以下两个原因\n允许用户处理错误，清理不需要的资源或在事件循环之前再次尝试请求 有时，需要允许回调在调用栈解除后但在事件循环之前调用 一个符合用户期望的例子如下\nconst server = net.createServer(); server.on('connection', (conn) =\u0026gt; {}) server.listen(8000) server.on('listening', () =\u0026gt; {}) listen() 在时间循环开始时允许，如果 \u0026rsquo;listening\u0026rsquo; 函数放在 setImmediate 中，那么有一定概率在轮询阶段收到新的请求的时候，\u0026rsquo;listening\u0026rsquo; 回调还没有注册。\n另一个例子是在构造函数中 emit 事件\nconst EventEmitter = require('events') const util = require('util') function MyEmitter() { EventEmitter.call(this) this.emit('event) } util.inherits(MyEmitter, EventEmitter) const myEmitter = new MyEmitter(); myEmitter.on('event', () =\u0026gt; { console.log('event occurred!') }) 上诉代码中的事件不会触发，因为脚本不会处理到为事件分配回调的地方。如果将 this.emit(\u0026rsquo;event) 放入 process.nextTick() 中执行，则会触发 \u0026rsquo;event\u0026rsquo; 事件。\n","id":9,"section":"posts","summary":"为什么要写这篇文章 有一段时间 nodejs 工作经历，面试总是被问到 Event Loop,虽然看过官网上的文章，奈何总是记不住，面试也答不上来。因此，写这篇文章来加","tags":null,"title":"The Node.js Event Loop, Timers and process.nextTick()","uri":"https://fearlessfe.github.io/blog/2022/02/event-loop/","year":"2022"},{"content":"Mysql 基础架构 Mysql 可以分为 Server 层和存储引擎层。\nServer 层包括连接器、分析器、优化器、执行器等，包括 Mysql 大多数的核心功能\n存储引擎复制数据的存储和提取，是插件式的，比较常用的存储引擎是 InnoDB.\n连接器 连接器主要负责与客户端建立连接、获取权限、维持和管理连接。连接命令如下\nmysql -h$ip -P$port -u$user -p 建立连接时，会校验用户名，密码。同时会读取权限信息，接下来这个连接里面的权限都会使用初始读取的权限信息。\n所以更改权限不会影响已存在的连接。\n分析器 对 SQL 语句做词法和语法分析\n优化器 为 SQL 语句选取最优的查询方案\n执行器 执行 SQL 语句\nredo log 和 binlog redo log 是 InnoDB 引擎特有的；binlog 是 Server 层的 redo log 是物理日志，记录的是“某个数据页的修改”；binlog 记录的原始语句，如“给ID=2这行的c字段加1” redolog 是循环写，binlog 是追加写。 更新数据时， InnoDB 更新数据到内存，写入 redo log，处于 prepare 状态。Server 层写入 binlog，然后提交事务，处于 commit 状态。通过两阶段提交来保证 redolog和binlog的一致性\ninnodb_flush_log_at_trx_commit 设置为 1，每次事务的 redo log都持久化到磁盘 sync_binlog 设置为 1，每次事务的 binlog 都持久化到磁盘\n这样可以保证服务 down 掉后，数据不回丢失\n事务 隔离级别\n读未提交：事务未提交时，它做的变更就可以被别的事务看到 读提交：事务提交后，它做的变更就可以被别的事务看到 可重复读：一个事务执行过程中看到的数据与事务启动时看到的数据一致。未提交的变更对其余事务也是不可见。 串行化：事务串行 在实现上，数据库会创建一个视图，访问的数据以视图的逻辑结果为准。 可重复读，视图在事务启动时创建，整改事务存在期间都使用这个视图 读提交，视图在 SQL 语句开始执行时创建\n","id":10,"section":"posts","summary":"Mysql 基础架构 Mysql 可以分为 Server 层和存储引擎层。 Server 层包括连接器、分析器、优化器、执行器等，包括 Mysql 大多数的核心功能 存储引擎复制数据的存储和提取，是插件式","tags":null,"title":"Mysql Base","uri":"https://fearlessfe.github.io/blog/2022/02/mysql-base/","year":"2022"},{"content":"Mutex 架构演进方向 golang 中的 Mutex 是互斥锁，它的实现不是一成不变的，主要经历了以下的变化\n初版：使用 flag 标记字段是否有锁 给新人机会：新的 goroutine 也有机会竞争锁 多给些机会：新来的和被唤醒的有更多机会竞争 解决饥饿：解决竞争问题，不让 goroutine 一直等待 初版互斥锁 初版互斥锁使用 CAS 指令实现，以下代码为 Mutex 的初版实现。\nCAS 指令将给定的值和一个内存地址中的值进行比较，如果是同一个值，就用新的值替换内存中的值。\n// CAS操作 func cas(val *int32, old, new int32) bool func semacquire(*int32) func semrelease(*int32) // 互斥锁结构 type Mutex struct { key int32 // 锁是否被持有的flag sema int32 // 信号量，用来阻塞/唤醒goroutine } func xadd(val *int32, delta int32) (new int32) { for { v := val if cas(val, v, v + delta) { return v + delta } } panic(\u0026quot;unreached\u0026quot;) } func (m *Mutex) Lock() { if xadd(\u0026amp;m.key, 1) == 1 { return } semacquire(\u0026amp;m.sema) // 进入队列 } func (m *Mutex) Unlock() { if xadd(\u0026amp;m.key, -1) == 0 { return } semrelease(\u0026amp;m.sema) // 唤醒队列中的goroutine } 初版实现通过 Mutex 的 key 属性作为标识，key 为0或1来表示锁是否被占用。\nUnlock 方法可以被任意的 goroutine 调用，即使是没有持有这个锁的 goroutine。所以使用 Mutex 时，一定要遵循“谁申请，谁释放”的原则。\n这种实现方式，按照 FIFO 的方式来获取锁。但是在高并发的情况下，会频繁的切换上下文，性能会有损耗。如果能够将锁交给正在占用 CPU 时间片的 goroutine 的话，会有更好的性能。\n给新人机会 这一版尝试给新来的 goroutine 获取锁的机会。\ntype Mutex struct { state int32 sema uint32 } // 32位 state 是复合字段。最小的一位表示锁是否占有，第二位表示是否有唤醒的 goroutine，剩下的代表等待该锁的 goroutine 数量 const ( mutexLocked = 1 \u0026lt;\u0026lt; iota // 1 mutexWoken // 2 mutexWaiterShift = iota // 2 ) func (m *Mutex) Lock() { // state 为 0,直接获取锁 if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { return } awoke := false for { old := m.state new := old | mutexLocked // 设置加锁的状态 // old 为有锁的状态，等待者加1 if old \u0026amp; mutexLocked != 0 { new = old + 1 \u0026lt;\u0026lt; mutexWaiterShift } if awoke { // goroutine 是被唤醒 // 将 mutexWoken 标志位变为0 new = new \u0026amp;^ mutexWoken } if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { // 无锁状态，直接获取锁 if old \u0026amp; mutexLocked == 0 { break } runtime.Semacquire(\u0026amp;m.sema) // 休眠 awoke = true // 唤醒后，awoke设置为true } } } 请求锁的 goroutine 分为新来的和被唤醒的，两者都会尝试获取锁。两者的区别见下表\n请求锁 锁被持有 锁未被持有 新来的goroutine waiter++ 休眠 获取锁 被唤醒的goroutine 清除mutexWoken，加入等待队列 清除mutexWoken，获取锁 func (m *Mutex) Unlock() { new := atomic.AddInt32(\u0026amp;m.state, -mutexLocked) // 去掉锁标志 if (new + mutexLocked) \u0026amp; mutexLocked == 0 { // unlock of unclocked mutex panic(\u0026quot;....\u0026quot;) } old := new for { // 没有等待者 或 (唤醒状态的goroutine或有锁) if old\u0026gt;\u0026gt;mutexWaiterShift == 0 || old\u0026amp;(mutexLocked|mutexWoken) != 0 { return } // 等待者减1，唤醒标志位设为1 new = (old - 1\u0026lt;\u0026lt;mutexWaiterShift) | mutexWoken if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { runtime.Semrelease(\u0026amp;m.sema) return } old = m.state } } 释放锁时，首先会将去掉锁的标志位。如果已经是释放的状态，则直接panic。 进入 for 循环后， 如果没有等待者，return 如果现在有唤醒的 goroutine 或者持有锁的 goroutine，直接交给其余的 goroutine 处理，return\n将等待者减1，设置唤醒标志位，然后唤醒等待的 goroutine.\n这一版本的实现，让新来的 goroutine 和唤醒的 goroutine 竞争，使得新来的 goroutine 可以获取锁，这样可以减少上下文的切换，提升性能。\n多给些机会 新来的 goroutine 和唤醒的 goroutine 如果没有获取到锁，会通过自旋的方式，尝试检查锁是否被释放。经过一定次数的尝试后，再执行原来的操作。改动后的 Lock 实现如下\nfunc (m *Mutex) Lock() { // state 为 0,直接获取锁 if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { return } awoke := false iter := 0 for { old := m.state new := old | mutexLocked if old \u0026amp; mutexLocked != 0 { if runtime_canSpin(iter) { // 新的goroutine \u0026amp;\u0026amp; 没有唤醒的goroutine \u0026amp;\u0026amp; 有等待者 \u0026amp;\u0026amp; 设置mutexWoken标志位 if !awoke \u0026amp;\u0026amp; old\u0026amp;mutexWoken == 0 \u0026amp;\u0026amp; old\u0026gt;\u0026gt;mutexWaiterShift != 0 \u0026amp;\u0026amp; atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken) { awoke = true // 设置 mutexWoken 标志位后，Unlock 方法不会唤醒新的 goroutine，自选期间获取锁的概率变大 } runtime_doSpin() iter++ continue } // 自旋结束，等待列表加1 new = old + 1\u0026lt;\u0026lt;mutexWaiterShift } if awoke { if new\u0026amp;mutexWoken == 0 { panic(\u0026quot;sync: inconsistent mutex state\u0026quot;) } new \u0026amp;^ = mutexWoken // 新状态清除唤醒标记 } if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { if old\u0026amp;mutexLocked == 0 { break } runtime_Semacquire(\u0026amp;m.sema) awoke = true iter = 0 } } } 上面自旋时，会设置唤醒标志位，导致等待队列的goroutine可能一直处于休眠状态，这样会产生饥饿的问题。\n解决饥饿 type Mutex struct { state int32 sema uint32 } const ( mutexLocked = 1 \u0026lt;\u0026lt; iota // 1 mutexWoken // 2 mutexStarving // 4 mutexWaiterShift = iota // 3 starvationThresholdNs = 1e6 // 1ms ) func (m *Mutex) Lock() { if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { return } // Slow path m.lockSlow() } func (m *Mutex) lockSlow() { var waitStartTime int64 starving := false awoke := false iter := 0 old := m.state for { // 锁未释放，且不处于饥饿状态。 可以自xuan if old\u0026amp;(mutexLocked|mutexStarving) == mutexLocked \u0026amp;\u0026amp; runtime_canSpin(iter) { if runtime_canSpin(iter) { if !awoke \u0026amp;\u0026amp; old\u0026amp;mutexWoken == 0 \u0026amp;\u0026amp; old\u0026gt;\u0026gt;mutexWaiterShift != 0 \u0026amp;\u0026amp; atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken) { // 新的goroutine \u0026amp;\u0026amp; 没有唤醒的goroutine \u0026amp;\u0026amp; 有等待 \u0026amp;\u0026amp; 将当前giroutine设为唤醒状态 awoke = true } runtime_doSpin() iter++ old = m.state // 获取锁的状态，之后会检查锁是否释放 continue } new := old // 非饥饿模式，加锁 if old\u0026amp;mutexStarving == 0 { new |= mutexLocked } // 饥饿模式或者有锁 if old\u0026amp;(mutexLocked|mutexStarving) != 0 { new += 1\u0026lt;\u0026lt;mutexWaiterShift } // 有锁，设置饥饿模式 if starving \u0026amp;\u0026amp; old\u0026amp;mutexLocked != 0 { new |= mutexStarving } if awoke { if new\u0026amp;mutexWoken == 0 { throw(\u0026quot;sync: inconsistent mutex state\u0026quot;) } new \u0026amp;^ = mutexWoken } if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { // 无锁，非饥饿模式 if old\u0026amp;(mutexLocked|mutexStarving) == 0 { break } // 处理饥饿状态 // 如果以前就在队列里，加入到队列头 queueLifo := waitStartTime != 0 if waitStartTime == 0 { waitStartTime = runtime_nanotime() } // 阻塞等待 runtime_Semacquire(\u0026amp;m.sema, queueLifo, 1) starving = starving || runtime_nanotime()-waitStartTime \u0026gt; starvationThresholdNs old = m.state // 如果锁已经处于饥饿状态，直接抢到锁，返回 if old\u0026amp;mutexStarving != 0 { if old\u0026amp;(mutexLocked|mutexWoken) != 0 || old\u0026gt;\u0026gt;mutexWaiterShift == 0 { throw(\u0026quot;sync: inconsistent mutex state\u0026quot;) } // 加锁且将waiter减1 delta := int32(mutexLocked - 1\u0026lt;\u0026lt;mutexWaiterShift) if !starving || old\u0026gt;\u0026gt;mutexWaiterShift == 1 { delta -= mutexStarving // 最后一个waiter或者已经不饥饿，清除标记 } atmoc.AddInt32(\u0026amp;m.state, delta) break } awoke = true iter = 0 } } else { old = m.state } } } ","id":11,"section":"posts","summary":"Mutex 架构演进方向 golang 中的 Mutex 是互斥锁，它的实现不是一成不变的，主要经历了以下的变化 初版：使用 flag 标记字段是否有锁 给新人机会：新的 goroutine 也有机会竞争锁 多给","tags":null,"title":"Golang Mutex 源码解析","uri":"https://fearlessfe.github.io/blog/2022/01/mutex/","year":"2022"}],"tags":[]}