---
title: "golang 里面的 mutex 是什么类型的锁？"
date: 2022-02-24T13:04:25+08:00
draft: false
---

最近面试 golang 被问到，golang 里面的 mutex 是什么类型的锁。很无奈，没了解过相关知识，没有答出来。

在 google 上一搜，对 Java 中锁介绍的资料最多，从不同的角度出发，锁的分类也不同。下图引用了[美图技术博客的分类](https://tech.meituan.com/2018/11/15/java-lock.html)

![图片](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png)

下面对其中的几类锁做一下简单的介绍，然后看看 mutex 是什么类型的锁。

### 乐观锁，悲观锁

乐观锁和悲观锁是以是否锁住同步资源来区分的。

很显然，mutex 是悲观锁，goroutine 获取锁后，相关的资源也会锁住，不让其余 goroutine 操作。

那么乐观锁是怎么处理多个 goroutine 的竞争关系呢？答案就是 CAS（Campare And Swap），先比较，再交换。
go里面的 atomic 包提供了相关方法,以 CompareAndSwapInt32 为例，该方法接受3个参数：

1. 内存地址,addr
2. 需要比较的值,old
3. 新的值,new

将 addr 处的值于 old 比较，如果相同，则将 addr 的值设置为 new，否则就返回 false。
```golang
atomic.CompareAndSwapInt32(&addr, old, new)
```

CAS 的性能会远高于锁，但是 CAS 也会有一些不适用的情况。

1. ABA 问题：CAS 只是比较值是否改变，如果该地址初始值为 A，别的 goroutine 将值改为 B，后来🈶️有 goroutine 将值改为 A。CAS 是不能判断这种变化的，可能会产生一些问题。
2. 只能对一个变量进行操作，无法保证多个变量的原子性。

除了 CAS，使用版本号也可以实现乐观锁。

版本号的原理是在数据中加一个 version 字段，每次字段改变后， version 加 1。每次更新时，先比较当前版本于数据目前的版本是否一致，否则就不能更新数据。

### 公平锁，非公平锁

按照多个 goroutine 竞争锁的时候，是否按照 FIFO 的顺序来获得锁，可以分为公平锁和非公平锁。

mutex 的实现经历了多个版本，早期版本时按照 FIFO 的方式来实现的，是公平锁。但后来的版本为了性能，该为了非公平锁。详细资料可参考[相关文章](https://fearlessfe.github.io/blog/2022/01/mutex/)。

目前 mutex 的实现是新的 goroutine 进来会先插队，插队失败后会排队。所以 mutex 是非公平锁。

### 其余类型

mutex 是互斥锁，只能由单个 gouroutine 获取，而且不能重复的去获取同一把锁。所以 mutex 是不可重入锁，排它锁。

### 总结

mutex 可以是 悲观锁，非公平锁，不可重入锁和排它锁。

### 参考资料

[【BAT面试题系列】面试官：你了解乐观锁和悲观锁吗？](https://www.cnblogs.com/kismetv/p/10787228.html)

[不可不说的Java“锁”事](https://tech.meituan.com/2018/11/15/java-lock.html)
