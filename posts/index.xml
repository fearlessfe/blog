<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on fearlessfe's blog</title><link>https://fearlessfe.github.io/blog/posts/</link><description>Recent content in Posts on fearlessfe's blog</description><generator>Hugo -- gohugo.io</generator><copyright>CC BY 4.0 CN</copyright><lastBuildDate>Fri, 17 Jun 2022 15:36:40 +0800</lastBuildDate><atom:link href="https://fearlessfe.github.io/blog/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Rust Traits</title><link>https://fearlessfe.github.io/blog/2022/06/rust-traits/</link><pubDate>Fri, 17 Jun 2022 15:36:40 +0800</pubDate><guid>https://fearlessfe.github.io/blog/2022/06/rust-traits/</guid><description>范型，traits和生命周期 范型 范型可以减少重复代码。 以下例子是从 i32 和 char 类型的 vec 中找到最大值。 fn largest_i32(list: &amp;amp;[i32]) -&amp;gt; i32 { let mut largest = list[0]; for &amp;amp;item in list { if item &amp;gt; largest { largest =</description></item><item><title>Rust Collections</title><link>https://fearlessfe.github.io/blog/2022/06/rust-collections/</link><pubDate>Thu, 16 Jun 2022 23:09:25 +0800</pubDate><guid>https://fearlessfe.github.io/blog/2022/06/rust-collections/</guid><description>常用集合 vector： 向量 string: 字符串 hash map vector 初始化向量 // 未赋值，必须显示的制定类型 let v: Vec&amp;lt;i32&amp;gt; = Vec::new(); // 如果需要初始化并赋值，可以使用 vec! 宏 // rust会自动</description></item><item><title>Rust Struct</title><link>https://fearlessfe.github.io/blog/2022/06/rust-struct/</link><pubDate>Thu, 16 Jun 2022 17:19:16 +0800</pubDate><guid>https://fearlessfe.github.io/blog/2022/06/rust-struct/</guid><description>结构体 定义,初始化和赋值 定义结构体使用 struct 关键字 struct User { active: bool, username: String, email: String, sign_in_count: u64, } fn main() { let user1 = User { email: String::from(&amp;quot;someone@example.com&amp;quot;), username: String::from(&amp;quot;someusername123&amp;quot;), active: true, sign_in_count: 1, }; user1.email = String::from(&amp;quot;someone@example.com&amp;quot;); } 整个结构体都是可以修改的，不</description></item><item><title>Rust Ownership</title><link>https://fearlessfe.github.io/blog/2022/06/rust-ownership/</link><pubDate>Thu, 16 Jun 2022 14:35:42 +0800</pubDate><guid>https://fearlessfe.github.io/blog/2022/06/rust-ownership/</guid><description>所有权系统 所有权是rust管理内存的一系列的规则。 rust 的每个值都有一个被称为 &amp;lsquo;owner&amp;rsquo; 的变量 每个时刻只能有一个 owner 当 owner 出作用域后，值会被丢弃 String 类型 字符串</description></item><item><title>Rust Basic</title><link>https://fearlessfe.github.io/blog/2022/06/rust-basic/</link><pubDate>Wed, 15 Jun 2022 20:21:04 +0800</pubDate><guid>https://fearlessfe.github.io/blog/2022/06/rust-basic/</guid><description>通用概念 变量和可变性 变量 rust 中变量默认是不可变的。下面的代码片段会报错，因为 x 是不可变的，不能重新赋值。 如果需要声明可变变量，需要加上关键字 mut</description></item><item><title>React 笔记</title><link>https://fearlessfe.github.io/blog/2022/05/react/</link><pubDate>Sun, 22 May 2022 22:09:49 +0800</pubDate><guid>https://fearlessfe.github.io/blog/2022/05/react/</guid><description>类组件与函数组件 函数组件能更好的复用逻辑 高阶组件缺点：组件静态方法，ref 传递 OOP思想与函数式思想，组合优于继承 setState 是否为异步 在 React 生命周期和</description></item><item><title>golang 里面的 mutex 是什么类型的锁？</title><link>https://fearlessfe.github.io/blog/2022/02/%E6%82%B2%E8%A7%82%E9%94%81%E4%B9%90%E8%A7%82%E9%94%81/</link><pubDate>Thu, 24 Feb 2022 13:04:25 +0800</pubDate><guid>https://fearlessfe.github.io/blog/2022/02/%E6%82%B2%E8%A7%82%E9%94%81%E4%B9%90%E8%A7%82%E9%94%81/</guid><description>最近面试 golang 被问到，golang 里面的 mutex 是什么类型的锁。很无奈，没了解过相关知识，没有答出来。 在 google 上一搜，对 Java 中锁介绍的资料最多，从不同的角度</description></item><item><title>The Node.js Event Loop, Timers and process.nextTick()</title><link>https://fearlessfe.github.io/blog/2022/02/event-loop/</link><pubDate>Wed, 23 Feb 2022 20:59:19 +0800</pubDate><guid>https://fearlessfe.github.io/blog/2022/02/event-loop/</guid><description>为什么要写这篇文章 有一段时间 nodejs 工作经历，面试总是被问到 Event Loop,虽然看过官网上的文章，奈何总是记不住，面试也答不上来。因此，写这篇文章来加</description></item><item><title>Golang Mutex 源码解析</title><link>https://fearlessfe.github.io/blog/2022/01/mutex/</link><pubDate>Sat, 22 Jan 2022 13:12:08 +0800</pubDate><guid>https://fearlessfe.github.io/blog/2022/01/mutex/</guid><description>Mutex 架构演进方向 golang 中的 Mutex 是互斥锁，它的实现不是一成不变的，主要经历了以下的变化 初版：使用 flag 标记字段是否有锁 给新人机会：新的 goroutine 也有机会竞争锁 多给</description></item></channel></rss>